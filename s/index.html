<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>縮網址 API 實測工具</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .loading {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 md:p-8">
    <div class="max-w-4xl mx-auto">
        <!-- Header -->
        <header class="text-center mb-10">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">縮網址 API 整合測試器</h1>
            <p class="text-gray-600 font-medium">解決 URL 錨點 (#) 與特殊字元傳輸問題</p>
        </header>

        <!-- Input Section -->
        <div class="bg-white rounded-xl shadow-md p-6 mb-8">
            <div class="flex flex-col md:flex-row gap-4">
                <input type="url" id="urlInput" placeholder="輸入長網址，包含 # 也可以測試" 
                    class="flex-1 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none">
                <button onclick="testAllApis()" id="btnTest" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-200">
                    同時測試所有 API
                </button>
            </div>
            <p class="mt-3 text-xs text-gray-400 italic text-center md:text-left">
                提示：我們會使用 encodeURIComponent() 處理網址，解決 # 符號被截斷的問題。
            </p>
        </div>

        <!-- Results Grid -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-12">
            <!-- Is.gd -->
            <div class="bg-white p-5 rounded-xl shadow border-t-4 border-green-500">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="font-bold text-lg">Is.gd</h3>
                    <span id="res-isgd" class="text-xs text-gray-400 font-bold">待測試</span>
                </div>
                <div id="link-isgd" class="mt-3 font-mono text-blue-600 break-all p-2 bg-gray-50 rounded min-h-[40px]"></div>
            </div>

            <!-- TinyURL -->
            <div class="bg-white p-5 rounded-xl shadow border-t-4 border-blue-400">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="font-bold text-lg">TinyURL</h3>
                    <span id="res-tinyurl" class="text-xs text-gray-400 font-bold">待測試</span>
                </div>
                <div id="link-tinyurl" class="mt-3 font-mono text-blue-600 break-all p-2 bg-gray-50 rounded min-h-[40px]"></div>
            </div>
        </div>

        <!-- Knowledge Section -->
        <div class="bg-blue-50 rounded-xl p-6 border border-blue-100 mb-8">
            <h2 class="text-lg font-bold text-blue-800 mb-3">為什麼會 Failed to fetch？</h2>
            <p class="text-blue-700 text-sm leading-relaxed mb-2">
                1. <strong>Proxy 限制：</strong> 當網址過長（超過 2000 字元）時，許多免費的 Proxy 服務會拒絕連線，導致程式報錯。
            </p>
            <p class="text-blue-700 text-sm leading-relaxed">
                2. <strong>編碼問題：</strong> 如果長網址內的 <code>#</code> 沒編碼好，請求會被截斷；如果編碼太多次，網址會變太長導致伺服器無法處理。
            </p>
        </div>
    </div>

    <script>
        // 改用更穩定的代理方案，並加入錯誤重試機制
        const PROXY = "https://corsproxy.io/?";

        async function testAllApis() {
            const longUrl = document.getElementById('urlInput').value.trim();
            if (!longUrl) {
                alert("請輸入網址");
                return;
            }

            // 對長網址進行標準 URL 編碼
            const encodedUrl = encodeURIComponent(longUrl);

            // 1. 測試 Is.gd
            const statusIsgd = document.getElementById(`res-isgd`);
            const linkIsgd = document.getElementById(`link-isgd`);
            statusIsgd.innerText = "請求中...";
            statusIsgd.className = "text-xs text-blue-500 font-bold";
            linkIsgd.innerText = "";
            
            const isgdApi = `https://is.gd/create.php?format=json&url=${encodedUrl}`;
            
            // 修正：不要對整個 Proxy URL 做二次 encodeURIComponent，除非必要
            // 這裡使用最直接的拼接方式
            fetch(`${PROXY}${encodeURIComponent(isgdApi)}`)
                .then(r => {
                    if(!r.ok) throw new Error(`HTTP ${r.status}`);
                    return r.json();
                })
                .then(data => {
                    if(data.shorturl) {
                        statusIsgd.innerText = "成功";
                        statusIsgd.className = "text-xs text-green-600 font-bold";
                        linkIsgd.innerHTML = `<a href="${data.shorturl}" target="_blank" class="underline hover:text-blue-800">${data.shorturl}</a>`;
                    } else {
                        throw new Error(data.errormessage || "未知錯誤");
                    }
                })
                .catch(e => {
                    statusIsgd.innerText = "失敗";
                    statusIsgd.className = "text-xs text-red-500 font-bold";
                    linkIsgd.innerText = "原因: " + e.message;
                });

            // 2. 測試 TinyURL
            const statusTiny = document.getElementById(`res-tinyurl`);
            const linkTiny = document.getElementById(`link-tinyurl`);
            statusTiny.innerText = "請求中...";
            statusTiny.className = "text-xs text-blue-500 font-bold";
            linkTiny.innerText = "";

            const tinyApi = `https://tinyurl.com/api-create.php?url=${encodedUrl}`;
            fetch(`${PROXY}${encodeURIComponent(tinyApi)}`)
                .then(r => {
                    if(!r.ok) throw new Error(`HTTP ${r.status}`);
                    return r.text();
                })
                .then(text => {
                    if(text.startsWith('http')) {
                        statusTiny.innerText = "成功";
                        statusTiny.className = "text-xs text-green-600 font-bold";
                        linkTiny.innerHTML = `<a href="${text}" target="_blank" class="underline hover:text-blue-800">${text}</a>`;
                    } else {
                        throw new Error("API 回傳無效數據");
                    }
                })
                .catch(e => {
                    statusTiny.innerText = "失敗";
                    statusTiny.className = "text-xs text-red-500 font-bold";
                    linkTiny.innerText = "原因: " + e.message;
                });
        }
    </script>
</body>
</html>