<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FluxTable v0.7.0</title>
    <style>
        :root {
            --bg-body: #121212;
            --bg-panel: #1e1e1e;
            --bg-input: #222;
            --border-color: #333;
            --border-hover: #555;
            --accent-color: #ccc;
            --highlight: #ff9800; /* Industrial Orange */
            --status-green: #00ff41;
            --status-red: #ff3333;
            --font-mono: 'JetBrains Mono', 'Roboto Mono', 'Consolas', monospace;
            --header-height: 42px;
        }

        * { box-sizing: border-box; outline: none; }

        body {
            background-color: var(--bg-body);
            color: var(--accent-color);
            font-family: var(--font-mono);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-size: 13px;
        }

        /* --- Header --- */
        header {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            padding: 0 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: var(--header-height);
            user-select: none;
            flex-shrink: 0;
        }

        .brand {
            font-weight: 800;
            letter-spacing: 1px;
            font-size: 1rem;
            color: #fff;
            text-transform: uppercase;
            margin-right: 20px;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toolbar-group {
            display: flex;
            background: var(--border-color);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            overflow: hidden;
        }

        .btn {
            background: var(--bg-panel);
            color: #777;
            border: none;
            padding: 0 12px;
            height: 24px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 12px;
            transition: all 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid #2a2a2a;
            position: relative;
            white-space: nowrap;
        }
        .btn:last-child { border-right: none; }

        .btn:hover { background: #333; color: #fff; }
        .btn:active { background: #222; }
        .btn:disabled { opacity: 0.3; cursor: not-allowed; }
        
        .btn.active {
            background: #333;
            color: var(--highlight);
            box-shadow: inset 0 -2px 0 var(--highlight);
        }

        /* Auto Width Toggle specific style */
        .btn-toggle-on { color: var(--status-green); }
        .btn-toggle-off { color: #555; }

        /* Icon Styles */
        #btn-bold { font-weight: 900; color: #aaa; }
        #btn-italic { font-style: italic; font-family: serif; color: #aaa; }
        #btn-strike { text-decoration: line-through; color: #aaa; }
        #btn-code { font-family: monospace; font-weight: bold; color: #aaa; letter-spacing: -1px; }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: #555;
            text-transform: uppercase;
        }
        .status-dot {
            width: 6px; height: 6px; background: #333; border-radius: 50%;
        }

        .power-select {
            background: #222;
            color: var(--highlight);
            border: 1px solid #444;
            font-size: 10px;
            padding: 2px 5px;
            border-radius: 2px;
            cursor: pointer;
            height: 24px;
        }

        /* --- Workspace & Pane Resizer --- */
        .workspace {
            display: flex;
            flex: 1;
            overflow: hidden;
            border-top: 1px solid #000;
        }

        .pane {
            display: flex;
            flex-direction: column;
            min-width: 200px;
            position: relative;
        }
        
        .pane-left { width: 60%; }
        .pane-right { flex: 1; }

        .pane-resizer {
            width: 5px;
            background: #111;
            border-left: 1px solid #333;
            border-right: 1px solid #333;
            cursor: col-resize;
            transition: background 0.2s;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .pane-resizer:hover, .pane-resizer.dragging {
            background: var(--highlight);
            border-color: var(--highlight);
        }
        .pane-resizer::after { content: "⋮"; color: #555; font-size: 10px; line-height: 10px; }
        .pane-resizer:hover::after { color: #000; }

        .pane-header {
            background: #181818;
            padding: 4px 10px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            color: #666;
            height: 28px;
            flex-shrink: 0;
        }
        
        .pane-actions { display: flex; gap: 8px; }
        .action-link { cursor: pointer; color: #666; text-decoration: none; font-size: 10px; }
        .action-link:hover { color: var(--highlight); }

        /* --- Visual Grid --- */
        .visual-container {
            flex: 1;
            overflow: auto;
            padding: 20px;
            background: #141414;
            background-image: 
                linear-gradient(var(--border-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--border-color) 1px, transparent 1px);
            background-size: 100px 100px;
            background-position: -1px -1px;
        }

        .flux-table {
            display: grid;
            gap: 1px;
            background: var(--border-color);
            border: 1px solid var(--border-color);
            width: fit-content;
            min-width: 100%; /* Important for auto-fit */
            box-shadow: 4px 4px 0 rgba(0,0,0,0.3);
        }

        .cell {
            background: var(--bg-panel);
            color: var(--accent-color);
            padding: 8px 12px;
            min-height: 36px;
            outline: none;
            white-space: pre-wrap;
            word-break: break-word;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .cell:hover { background: #252525; }
        .cell:focus {
            background: #000;
            color: #fff;
            box-shadow: inset 0 0 0 1px var(--highlight);
            z-index: 10;
        }

        .cell-header {
            background: #222;
            font-weight: 700;
            color: #888;
            text-align: center;
            position: relative; /* For col-resizer */
        }
        .cell-header.active-col {
            color: var(--highlight);
            background: #2a2a2a;
            border-bottom: 2px solid var(--highlight);
        }
        .cell-header:focus { color: #fff; background: #000; }

        /* Column Resizer Handle */
        .col-resizer {
            position: absolute;
            top: 0;
            right: 0;
            width: 5px;
            height: 100%;
            cursor: col-resize;
            background: transparent;
            z-index: 20;
            transition: background 0.2s;
        }
        .col-resizer:hover, .col-resizer.dragging {
            background: var(--highlight);
        }
        /* Only show col-resizer when not in auto mode or force show on hover? 
           Design choice: Show only when manual mode is active or always? 
           Prompt: "turn off auto column width so can manually pull".
           We will hide it if autoWidth is true.
        */
        .flux-table.auto-width .col-resizer {
            display: none;
        }

        /* Helpers */
        .align-left { text-align: left; }
        .align-center { text-align: center; }
        .align-right { text-align: right; }
        
        /* Rendered Markdown */
        .md-bold { font-weight: bold; color: #fff; }
        .md-italic { font-style: italic; }
        .md-strike { text-decoration: line-through; opacity: 0.6; }
        .md-code { background: #333; padding: 2px 4px; border-radius: 2px; color: #aaffaa; font-family: monospace; font-size: 0.9em; }

        /* --- Code Editor --- */
        .code-editor {
            flex: 1;
            background: var(--bg-input);
            color: #ccc;
            border: none;
            resize: none;
            padding: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            line-height: 1.6;
            white-space: pre;
            overflow: auto;
        }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-body); }
        ::-webkit-scrollbar-thumb { background: #444; }
        ::-webkit-scrollbar-thumb:hover { background: #666; }

    </style>
</head>
<body>

<header>
    <div class="toolbar-section">
        <div class="brand">FluxTable <span style="color:#666; font-size: 0.8em;">v0.7.0</span></div>
        
        <div class="toolbar-group">
            <button class="btn" id="btn-undo" onclick="undo()" title="Undo (Ctrl+Z)">↶</button>
            <button class="btn" id="btn-redo" onclick="redo()" title="Redo (Ctrl+Y)">↷</button>
        </div>

        <div class="toolbar-group">
            <button class="btn" id="btn-bold" onclick="formatText('**')" title="Bold">B</button>
            <button class="btn" id="btn-italic" onclick="formatText('*')" title="Italic">I</button>
            <button class="btn" id="btn-strike" onclick="formatText('~~')" title="Strike">S</button>
            <button class="btn" id="btn-code" onclick="formatText('`')" title="Code">&lt;/&gt;</button>
        </div>

        <div class="toolbar-group">
            <button class="btn" id="btn-left" onclick="setColAlign('left')" title="Left">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M3 18h18v-2H3v2zm0-5h12v-2H3v2zm0-7v2h18V6H3z"/></svg>
            </button>
            <button class="btn" id="btn-center" onclick="setColAlign('center')" title="Center">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M3 18h18v-2H3v2zm4-5h10v-2H7v2zm-4-7v2h18V6H3z"/></svg>
            </button>
            <button class="btn" id="btn-right" onclick="setColAlign('right')" title="Right">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M3 18h18v-2H3v2zm6-5h12v-2H9v2zm-6-7v2h18V6H3z"/></svg>
            </button>
        </div>
        
        <!-- Toggle & Ops -->
        <div class="toolbar-group">
            <button class="btn" id="btn-auto-width" onclick="toggleAutoWidth()" title="Toggle Smart Column Width" style="font-weight:bold;">
                ↔ Auto
            </button>
            <button class="btn" onclick="transposeTable()" title="Transpose (斜對角翻轉)">
                <span style="font-family:serif; font-weight:bold;">A<sup>T</sup></span>
            </button>
            <button class="btn" onclick="rotateTableCCW()" title="Rotate -90° (逆時針旋轉)">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
            </button>
        </div>
    </div>

    <div class="toolbar-section">
        <div class="toolbar-group">
            <button class="btn" onclick="insertRow()" title="Add Row">+ Row</button>
            <button class="btn" onclick="insertCol()" title="Add Col">+ Col</button>
            <button class="btn" id="btn-smart-delete" onclick="deleteTarget()" title="Delete Row/Col" style="color:#aa4444; min-width: 60px;">Del</button>
        </div>
        
        <select class="power-select" onchange="runColumnOp(this.value); this.value=''">
            <option value="">Col Ops</option>
            <option value="clear">Clear Col</option>
            <option value="upper">UPPERCASE</option>
            <option value="wrap">Wrap ( )</option>
        </select>
        
        <div class="status-indicator">
            <div id="statusLight" class="status-dot" style="background: var(--status-green);"></div>
        </div>
    </div>
</header>

<div class="workspace" id="workspace">
    <div class="pane pane-left" id="paneLeft">
        <div class="pane-header">
            <span>VISUAL GRID</span>
            <span style="font-size:0.9em; color:#444;" id="selectionInfo">No Selection</span>
        </div>
        <div class="visual-container" id="visualContainer">
            <div id="grid" class="flux-table"></div>
        </div>
    </div>

    <!-- Draggable Pane Resizer -->
    <div class="pane-resizer" id="paneResizer"></div>

    <div class="pane pane-right" id="paneRight">
        <div class="pane-header">
            <select id="codeMode" style="background:transparent; color:#888; border:none; cursor:pointer;" onchange="switchCodeMode()">
                <option value="markdown">MARKDOWN</option>
                <option value="csv">CSV DATA</option>
            </select>
            <div class="pane-actions">
                <a class="action-link" onclick="copyCode()">COPY</a>
                <a class="action-link" onclick="downloadCode()">SAVE</a>
            </div>
        </div>
        <textarea id="codeEditor" class="code-editor" spellcheck="false"></textarea>
    </div>
</div>

<script>
    // --- FluxTable v0.7.0 Core Logic ---

    const defaultState = {
        headers: ["Empire", "Duration", "Notes"],
        rows: [
            ["Roman Empire", "27 BC - 395 AD", "The **Senate** and People of Rome"],
            ["Byzantine", "395 AD - 1453 AD", "Capital: *Constantinople*"],
            ["Ottoman", "1299 - 1922", "Spanned three continents"]
        ],
        alignments: ["left", "left", "left"],
        autoWidth: true,
        colWidths: [] // Stores Manual pixel widths e.g., [150, 100, 300]
    };

    let appState = JSON.parse(localStorage.getItem('flux_v007')) || JSON.parse(JSON.stringify(defaultState));
    // Migration for older versions or missing fields
    if (appState.autoWidth === undefined) appState.autoWidth = true;
    if (!appState.colWidths) appState.colWidths = [];

    let currentFocus = { row: 0, col: 0 }; 
    let isComposing = false; 

    // History
    const historyStack = [];
    let historyPointer = -1;
    const MAX_HISTORY = 50;

    // Elements
    const gridEl = document.getElementById('grid');
    const editorEl = document.getElementById('codeEditor');
    const statusLight = document.getElementById('statusLight');
    const selectionInfo = document.getElementById('selectionInfo');
    const btnUndo = document.getElementById('btn-undo');
    const btnRedo = document.getElementById('btn-redo');
    const btnDelete = document.getElementById('btn-smart-delete');
    const btnAutoWidth = document.getElementById('btn-auto-width');

    const btnMap = {
        bold: document.getElementById('btn-bold'),
        italic: document.getElementById('btn-italic'),
        strike: document.getElementById('btn-strike'),
        code: document.getElementById('btn-code'),
        left: document.getElementById('btn-left'),
        center: document.getElementById('btn-center'),
        right: document.getElementById('btn-right'),
    };

    function init() {
        pushHistory(appState, true);
        renderVisual();
        renderCode();
        updateToolbarState();
        setupGlobalKeys();
        setupPaneResizer();
        
        editorEl.addEventListener('input', () => {
            if (isComposing) return;
            setStatus('syncing');
            clearTimeout(window.saveTimer);
            window.saveTimer = setTimeout(handleCodeInput, 600);
        });
    }

    // --- Pane Resizer Logic ---
    function setupPaneResizer() {
        const resizer = document.getElementById('paneResizer');
        const leftPane = document.getElementById('paneLeft');
        const workspace = document.getElementById('workspace');
        let isResizing = false;

        resizer.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizer.classList.add('dragging');
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const containerWidth = workspace.getBoundingClientRect().width;
            const x = e.clientX - workspace.getBoundingClientRect().left;
            const percentage = (x / containerWidth) * 100;
            if (percentage > 10 && percentage < 90) {
                leftPane.style.width = `${percentage}%`;
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                resizer.classList.remove('dragging');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        });
    }

    // --- Column Resizer Logic (Manual Mode) ---
    function makeColumnResizable(headerCell, colIndex) {
        const resizer = document.createElement('div');
        resizer.className = 'col-resizer';
        headerCell.appendChild(resizer);

        let startX, startWidth;

        resizer.addEventListener('mousedown', (e) => {
            e.stopPropagation(); // Don't trigger cell focus
            startX = e.clientX;
            // Get current width from computed style or appState
            // We rely on appState.colWidths being populated if in manual mode
            startWidth = appState.colWidths[colIndex] || headerCell.getBoundingClientRect().width;
            
            document.documentElement.addEventListener('mousemove', doDrag, false);
            document.documentElement.addEventListener('mouseup', stopDrag, false);
            headerCell.classList.add('resizing');
        });

        function doDrag(e) {
            const newWidth = Math.max(50, startWidth + e.clientX - startX); // Min 50px
            appState.colWidths[colIndex] = newWidth;
            
            // Direct update for performance
            // We need to construct the whole grid template string again
            updateGridTemplate();
        }

        function stopDrag(e) {
            document.documentElement.removeEventListener('mousemove', doDrag, false);
            document.documentElement.removeEventListener('mouseup', stopDrag, false);
            headerCell.classList.remove('resizing');
            saveToLocal(); // Save new widths
        }
    }

    function toggleAutoWidth() {
        appState.autoWidth = !appState.autoWidth;
        
        // If switching to Manual, initialize colWidths with current computed widths
        if (!appState.autoWidth) {
            const headers = document.querySelectorAll('.cell-header');
            appState.colWidths = Array.from(headers).map(h => h.getBoundingClientRect().width);
        }
        
        updateState(appState);
        renderVisual();
    }

    function calculateSmartWidths() {
        // Calculate weighted width for Auto Fit
        // 1. Calculate max length of text in each column
        const colMaxLens = new Array(appState.headers.length).fill(0);
        
        // Check headers
        appState.headers.forEach((h, i) => colMaxLens[i] = Math.max(colMaxLens[i], (h||"").length));
        
        // Check rows (limit to first 50 rows for perf if needed, but here we do all)
        appState.rows.forEach(row => {
            row.forEach((cell, i) => {
                if (colMaxLens[i] !== undefined) {
                    colMaxLens[i] = Math.max(colMaxLens[i], (cell||"").length);
                }
            });
        });

        // 2. Generate fr values based on length
        // Base weight = 1 (for min width), add log scale or linear scale of length
        // To prevent huge columns, maybe cap length
        return colMaxLens.map(len => {
            const weight = Math.max(1, Math.min(len, 50)); // Cap at 50 chars weight
            // Use a slightly non-linear curve so small cols don't get crushed
            return `minmax(${Math.min(80, len*10)}px, ${Math.sqrt(weight)}fr)`; 
        }).join(" ");
    }

    function updateGridTemplate() {
        if (appState.autoWidth) {
            gridEl.classList.add('auto-width');
            gridEl.style.gridTemplateColumns = calculateSmartWidths();
        } else {
            gridEl.classList.remove('auto-width');
            // Use manual widths
            const widths = appState.colWidths.map((w, i) => {
                // Fallback if width missing
                return (w ? `${w}px` : `minmax(100px, 1fr)`);
            }).join(" ");
            gridEl.style.gridTemplateColumns = widths;
        }
    }

    // --- Visual Rendering ---

    function renderVisual() {
        gridEl.innerHTML = '';
        const colCount = appState.headers.length;
        
        updateGridTemplate();
        
        // Sync colWidths array length if cols added/removed
        while (appState.colWidths.length < colCount) appState.colWidths.push(null);

        // Update Auto Width Button UI
        if (appState.autoWidth) {
            btnAutoWidth.classList.add('btn-toggle-on');
            btnAutoWidth.classList.remove('btn-toggle-off');
            btnAutoWidth.style.color = 'var(--status-green)';
        } else {
            btnAutoWidth.classList.add('btn-toggle-off');
            btnAutoWidth.classList.remove('btn-toggle-on');
            btnAutoWidth.style.color = '#555';
        }

        appState.headers.forEach((text, colIndex) => {
            const cell = createCell(-1, colIndex, text, true);
            // Add Resizer if in Manual Mode
            if (!appState.autoWidth) {
                makeColumnResizable(cell, colIndex);
            }
            gridEl.appendChild(cell);
        });

        appState.rows.forEach((row, rowIndex) => {
            while(row.length < colCount) row.push("");
            row.forEach((text, colIndex) => {
                gridEl.appendChild(createCell(rowIndex, colIndex, text, false));
            });
        });

        restoreFocus();
        highlightActiveColumn();
    }

    function createCell(row, col, text, isHeader) {
        const cell = document.createElement('div');
        cell.className = isHeader ? 'cell cell-header' : 'cell';
        cell.contentEditable = true;
        
        const align = appState.alignments[col] || 'left';
        cell.classList.add(`align-${align}`);
        if(isHeader) cell.style.textAlign = align;

        cell.dataset.row = row;
        cell.dataset.col = col;

        const isFocused = (currentFocus.row === row && currentFocus.col === col);
        
        if (isFocused && document.activeElement === cell) {
            cell.innerText = text;
        } else {
            cell.innerHTML = parseMarkdownToHTML(text);
        }

        cell.addEventListener('compositionstart', () => { isComposing = true; });
        cell.addEventListener('compositionend', (e) => { 
            isComposing = false; 
            handleCellInput(e.target, row, col); 
        });

        cell.onfocus = () => {
            currentFocus = { row, col };
            if (cell.innerHTML !== text) cell.innerText = appState.rows[row] ? appState.rows[row][col] : appState.headers[col];
            updateToolbarState();
            selectionInfo.innerText = isHeader ? `HEAD: ${col+1}` : `ROW: ${row+1} COL: ${col+1}`;
            highlightActiveColumn();
        };
        
        cell.onblur = () => {
             if (cell.innerText === text) cell.innerHTML = parseMarkdownToHTML(text);
             pushHistory(appState);
        };

        cell.oninput = (e) => {
            if (isComposing) return;
            handleCellInput(e.target, row, col);
        };

        return cell;
    }

    function highlightActiveColumn() {
        document.querySelectorAll('.cell-header').forEach(el => el.classList.remove('active-col'));
        const header = document.querySelector(`.cell-header[data-col="${currentFocus.col}"]`);
        if (header) header.classList.add('active-col');
        
        if (currentFocus.row === -1) {
            btnDelete.innerText = "Del Col";
            btnDelete.title = "Delete Column (Focus: Header)";
        } else {
            btnDelete.innerText = "Del Row";
            btnDelete.title = "Delete Row (Focus: Body)";
        }
    }

    function handleCellInput(target, row, col) {
        const val = target.innerText;
        if (row === -1) appState.headers[col] = val;
        else appState.rows[row][col] = val;
        
        saveToLocal();
        // Recalculate widths if auto mode is on and typing changes length significantly?
        // To avoid jitter, maybe only re-calc on blur or debounce.
        // For now, let's keep it stable and not re-render grid CSS on every char.
        renderCode();
    }

    // --- State & History ---

    function pushHistory(state, isInitial = false) {
        const stateStr = JSON.stringify(state);
        if (historyPointer >= 0 && historyStack[historyPointer] === stateStr && !isInitial) return;
        if (historyPointer < historyStack.length - 1) historyStack.splice(historyPointer + 1);
        historyStack.push(stateStr);
        if (historyStack.length > MAX_HISTORY) historyStack.shift();
        else historyPointer++;
        updateUndoRedoUI();
    }

    function undo() {
        if (historyPointer > 0) {
            historyPointer--;
            restoreStateFromHistory();
        }
    }
    function redo() {
        if (historyPointer < historyStack.length - 1) {
            historyPointer++;
            restoreStateFromHistory();
        }
    }
    function restoreStateFromHistory() {
        appState = JSON.parse(historyStack[historyPointer]);
        saveToLocal();
        renderVisual();
        renderCode();
        updateToolbarState();
        updateUndoRedoUI();
    }
    function updateUndoRedoUI() {
        btnUndo.disabled = historyPointer <= 0;
        btnRedo.disabled = historyPointer >= historyStack.length - 1;
    }

    function updateState(newState, recordHistory = true) {
        appState = newState;
        ensureAlignmentsSync();
        saveToLocal();
        if (recordHistory) pushHistory(appState);
    }

    function ensureAlignmentsSync() {
        const count = appState.headers.length;
        while(appState.alignments.length < count) appState.alignments.push('left');
        if(appState.alignments.length > count) appState.alignments = appState.alignments.slice(0, count);
    }

    function saveToLocal() {
        setStatus('syncing');
        localStorage.setItem('flux_v007', JSON.stringify(appState));
        setTimeout(() => setStatus('ready'), 200);
    }
    function setStatus(state) {
        statusLight.style.backgroundColor = state === 'syncing' ? 'var(--status-red)' : 'var(--status-green)';
    }

    // --- Matrix Ops ---
    function getCompleteMatrix() {
        const width = appState.headers.length;
        const matrix = [ [...appState.headers] ]; 
        appState.rows.forEach(row => {
            const cleanRow = [...row];
            while(cleanRow.length < width) cleanRow.push("");
            matrix.push(cleanRow);
        });
        return matrix;
    }
    function setMatrix(matrix) {
        if (!matrix || matrix.length === 0) return;
        appState.headers = matrix[0];
        appState.rows = matrix.slice(1);
        appState.alignments = new Array(appState.headers.length).fill('left');
        // Reset manual widths on structure change
        appState.colWidths = []; 
        updateState(appState);
        renderVisual();
        renderCode();
    }
    function transposeTable() {
        const matrix = getCompleteMatrix();
        if(matrix.length === 0) return;
        const newMatrix = matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
        setMatrix(newMatrix);
    }
    function rotateTableCCW() {
        const matrix = getCompleteMatrix();
        if(matrix.length === 0) return;
        const oldRows = matrix.length;
        const oldCols = matrix[0].length;
        const newMatrix = [];
        for (let c = oldCols - 1; c >= 0; c--) {
            const newRow = [];
            for (let r = 0; r < oldRows; r++) { newRow.push(matrix[r][c]); }
            newMatrix.push(newRow);
        }
        setMatrix(newMatrix);
    }

    // --- Toolbar & Utils ---
    function deleteTarget() {
        if (currentFocus.row === -1) deleteCol(); else deleteRow();
    }
    function runColumnOp(op) {
        if (!op || currentFocus.col === undefined) return;
        const col = currentFocus.col;
        if (op === 'clear') {
             if(confirm('Clear this column?')) appState.rows.forEach(r => r[col] = "");
        } else if (op === 'upper') {
            appState.rows.forEach(r => { if(r[col]) r[col] = r[col].toUpperCase(); });
            appState.headers[col] = appState.headers[col].toUpperCase();
        } else if (op === 'wrap') {
            appState.rows.forEach(r => { if(r[col]) r[col] = `(${r[col]})`; });
        }
        updateState(appState);
        renderVisual();
        renderCode();
    }
    function insertRow() {
        const newRow = new Array(appState.headers.length).fill("");
        appState.rows.splice(currentFocus.row + 1, 0, newRow);
        updateState(appState);
        renderVisual();
        renderCode();
    }
    function deleteRow() {
        if (currentFocus.row === -1) return;
        appState.rows.splice(currentFocus.row, 1);
        if (currentFocus.row >= appState.rows.length) currentFocus.row--;
        updateState(appState);
        renderVisual();
        renderCode();
    }
    function insertCol() {
        appState.headers.splice(currentFocus.col + 1, 0, "New");
        appState.alignments.splice(currentFocus.col + 1, 0, "left");
        appState.colWidths.splice(currentFocus.col + 1, 0, null);
        appState.rows.forEach(r => r.splice(currentFocus.col + 1, 0, ""));
        currentFocus.col++;
        updateState(appState);
        renderVisual();
        renderCode();
    }
    function deleteCol() {
        if(appState.headers.length <= 1) { alert("Cannot delete the last column."); return; }
        appState.headers.splice(currentFocus.col, 1);
        appState.alignments.splice(currentFocus.col, 1);
        appState.colWidths.splice(currentFocus.col, 1);
        appState.rows.forEach(r => r.splice(currentFocus.col, 1));
        if(currentFocus.col >= appState.headers.length) currentFocus.col--;
        updateState(appState);
        renderVisual();
        renderCode();
    }

    function formatText(syntax) {
        const { row, col } = currentFocus;
        if (col === undefined) return;
        let val = row === -1 ? appState.headers[col] : appState.rows[row][col];
        val = val || "";
        if (val.includes(syntax)) val = val.split(syntax).join("");
        else val = syntax + val + syntax;
        if (row === -1) appState.headers[col] = val;
        else appState.rows[row][col] = val;
        updateState(appState);
        renderVisual();
        renderCode();
    }

    function setColAlign(align) {
        if (currentFocus.col === undefined) return;
        appState.alignments[currentFocus.col] = align;
        updateState(appState);
        renderVisual();
        renderCode();
    }

    function updateToolbarState() {
        let text = "";
        if (currentFocus.row === -1) text = appState.headers[currentFocus.col] || "";
        else if (appState.rows[currentFocus.row]) text = appState.rows[currentFocus.row][currentFocus.col] || "";

        // Fix: Better regex to distinguish bold and italic
        // Check bold first
        const hasBold = /\*\*(?:[^*]|\*(?!\*))+\*\*/.test(text);
        // Check italic but ignore double asterisks
        const textNoBold = text.replace(/\*\*(?:[^*]|\*(?!\*))+\*\*/g, "");
        const hasItalic = /\*(?:[^*])+\*/.test(textNoBold);

        btnMap.bold.classList.toggle('active', hasBold);
        btnMap.italic.classList.toggle('active', hasItalic);
        btnMap.strike.classList.toggle('active', /~~.*~~/.test(text));
        btnMap.code.classList.toggle('active', /`.*`/.test(text));

        const align = appState.alignments[currentFocus.col] || 'left';
        btnMap.left.classList.toggle('active', align === 'left');
        btnMap.center.classList.toggle('active', align === 'center');
        btnMap.right.classList.toggle('active', align === 'right');
    }

    // --- Code IO ---
    function renderCode() {
        const mode = document.getElementById('codeMode').value;
        let output = "";
        ensureAlignmentsSync();
        if (mode === 'markdown') {
            output += "| " + appState.headers.join(" | ") + " |\n";
            output += "|";
            for(let i=0; i < appState.headers.length; i++) {
                const a = appState.alignments[i] || 'left';
                output += (a === 'center' ? " :---: |" : (a === 'right' ? " ---: |" : " :--- |"));
            }
            output += "\n";
            appState.rows.forEach(row => {
                output += "| " + row.map(c => (c||"").replace(/\n/g, "<br>")).join(" | ") + " |\n";
            });
        } else {
            output += appState.headers.join(",") + "\n";
            appState.rows.forEach(row => output += row.join(",") + "\n");
        }
        editorEl.value = output;
    }
    function handleCodeInput() {
        const lines = editorEl.value.trim().split("\n");
        const mode = document.getElementById('codeMode').value;
        if (mode === 'markdown') {
            const dataLines = lines.filter(l => l.includes("|") && !l.includes("---"));
            const dashLine = lines.find(l => l.includes("---") && l.includes("|"));
            if(dataLines.length > 0) {
                const newHeaders = dataLines[0].split("|").slice(1,-1).map(s=>s.trim());
                if (newHeaders.length > 0) {
                    appState.headers = newHeaders;
                    if (dashLine) {
                        const alignParts = dashLine.split("|").slice(1,-1).map(s => s.trim());
                        if (alignParts.length === newHeaders.length) {
                             appState.alignments = alignParts.map(s => {
                                 if (s.startsWith(":") && s.endsWith(":")) return "center";
                                 if (s.endsWith(":")) return "right";
                                 return "left";
                             });
                        }
                    }
                    ensureAlignmentsSync();
                    if(dataLines.length > 1) {
                        appState.rows = dataLines.slice(1).map(l => {
                            return l.split("|").slice(1,-1).map(s=>s.trim().replace(/<br>/g, "\n"));
                        });
                    } else { appState.rows = []; }
                    // Reset Manual Widths on Import
                    appState.colWidths = [];
                }
            }
        }
        updateState(appState);
        renderVisual();
    }
    
    function setupGlobalKeys() {
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); if(e.shiftKey) redo(); else undo(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'b') { e.preventDefault(); formatText('**'); }
        });
    }
    function parseMarkdownToHTML(text) {
        if (!text) return "";
        return text.replace(/</g, "&lt;").replace(/>/g, "&gt;")
            .replace(/\*\*(.*?)\*\*/g, '<span class="md-bold">$1</span>')
            .replace(/\*(.*?)\*/g, '<span class="md-italic">$1</span>')
            .replace(/~~(.*?)~~/g, '<span class="md-strike">$1</span>')
            .replace(/`(.*?)`/g, '<span class="md-code">$1</span>')
            .replace(/\n/g, '<br>');
    }
    function restoreFocus() {
        const el = document.querySelector(`.cell[data-row="${currentFocus.row}"][data-col="${currentFocus.col}"]`);
        if (el) el.focus();
    }
    function switchCodeMode() { renderCode(); }
    function copyCode() { editorEl.select(); document.execCommand('copy'); }
    function downloadCode() {
        const text = editorEl.value;
        const mode = document.getElementById('codeMode').value;
        const blob = new Blob([text], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = mode === 'markdown' ? 'table.md' : 'table.csv';
        a.click();
    }

    init();

</script>
</body>
</html>