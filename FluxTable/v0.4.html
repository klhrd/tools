<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FluxTable v0.4.0</title>
    <style>
        :root {
            --bg-body: #121212;
            --bg-panel: #1e1e1e;
            --bg-input: #222;
            --border-color: #333;
            --border-hover: #555;
            --accent-color: #ccc;
            --highlight: #ff9800; /* Industrial Orange */
            --status-green: #00ff41;
            --status-red: #ff3333;
            --font-mono: 'JetBrains Mono', 'Roboto Mono', 'Consolas', monospace;
            --header-height: 42px;
        }

        * { box-sizing: border-box; outline: none; }

        body {
            background-color: var(--bg-body);
            color: var(--accent-color);
            font-family: var(--font-mono);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-size: 13px;
        }

        /* --- Compact Toolbar --- */
        header {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            padding: 0 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: var(--header-height);
            user-select: none;
        }

        .brand {
            font-weight: 800;
            letter-spacing: 1px;
            font-size: 1rem;
            color: #fff;
            text-transform: uppercase;
            margin-right: 20px;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toolbar-group {
            display: flex;
            background: var(--border-color);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            overflow: hidden;
        }

        .btn {
            background: var(--bg-panel);
            color: #777;
            border: none;
            padding: 0 12px;
            height: 24px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 12px;
            transition: all 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid #2a2a2a;
            position: relative;
        }
        .btn:last-child { border-right: none; }

        .btn:hover { background: #333; color: #fff; }
        .btn:active { background: #222; }
        .btn:disabled { opacity: 0.3; cursor: not-allowed; }
        
        /* Active State (Industrial Orange) */
        .btn.active {
            background: #333;
            color: var(--highlight);
            box-shadow: inset 0 -2px 0 var(--highlight);
        }

        /* Tooltip hack */
        .btn[title]:hover::after {
            content: attr(title);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #000;
            color: #fff;
            padding: 4px 6px;
            font-size: 10px;
            border-radius: 2px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            margin-top: 4px;
            border: 1px solid #333;
        }
        
        /* --- Self-Reflective Styles for Buttons --- */
        #btn-bold { font-weight: 900; color: #aaa; }
        #btn-bold:hover { color: #fff; }
        #btn-italic { font-style: italic; font-family: 'Times New Roman', serif; font-size: 13px; color: #aaa; }
        #btn-italic:hover { color: #fff; }
        #btn-strike { text-decoration: line-through; color: #aaa; }
        #btn-strike:hover { color: #fff; }
        #btn-code { font-family: 'Courier New', monospace; font-weight: bold; color: #aaa; letter-spacing: -1px; }
        #btn-code:hover { color: #fff; }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: #555;
            text-transform: uppercase;
        }
        .status-dot {
            width: 6px; height: 6px; background: #333; border-radius: 50%;
        }

        /* --- Main Workspace --- */
        .workspace {
            display: flex;
            flex: 1;
            overflow: hidden;
            border-top: 1px solid #000;
        }

        .pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            min-width: 0;
            position: relative;
        }

        .pane-header {
            background: #181818;
            padding: 4px 10px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            color: #666;
            height: 28px;
        }
        
        .pane-actions {
            display: flex;
            gap: 5px;
        }
        
        .action-link {
            cursor: pointer;
            color: #666;
            text-decoration: none;
            font-size: 10px;
            padding: 2px 5px;
            border-radius: 2px;
        }
        .action-link:hover { color: var(--highlight); background: #222; }

        /* --- Visual Grid --- */
        .visual-container {
            flex: 1;
            overflow: auto;
            padding: 20px;
            background: #141414;
            /* Subtle grid background */
            background-image: 
                linear-gradient(var(--border-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--border-color) 1px, transparent 1px);
            background-size: 100px 100px;
            background-position: -1px -1px;
        }

        .flux-table {
            display: grid;
            gap: 1px;
            background: var(--border-color);
            border: 1px solid var(--border-color);
            width: fit-content;
            min-width: 100%;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.3);
        }

        .cell {
            background: var(--bg-panel);
            color: var(--accent-color);
            padding: 8px 12px;
            min-height: 36px;
            outline: none;
            white-space: pre-wrap;
            word-break: break-word;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .cell:hover { background: #252525; }

        .cell:focus {
            background: #000;
            color: #fff;
            box-shadow: inset 0 0 0 1px var(--highlight);
            z-index: 10;
        }

        .cell-header {
            background: #222;
            font-weight: 700;
            color: #888;
            text-align: center;
        }
        .cell-header:focus { color: #fff; background: #000; }

        /* Rendered Markdown Styles in Grid */
        .md-bold { font-weight: bold; color: #fff; }
        .md-italic { font-style: italic; }
        .md-strike { text-decoration: line-through; opacity: 0.6; }
        .md-code { background: #333; padding: 2px 4px; border-radius: 2px; color: #aaffaa; font-family: monospace; font-size: 0.9em; }

        /* Helpers */
        .align-left { text-align: left; }
        .align-center { text-align: center; }
        .align-right { text-align: right; }

        /* --- Code Editor --- */
        .code-editor {
            flex: 1;
            background: var(--bg-input);
            color: #ccc;
            border: none;
            resize: none;
            padding: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            line-height: 1.6;
            white-space: pre;
            overflow: auto;
        }

        /* Scrollbars */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-body); }
        ::-webkit-scrollbar-thumb { background: #444; }
        ::-webkit-scrollbar-thumb:hover { background: #666; }

    </style>
</head>
<body>

<header>
    <div class="toolbar-section">
        <div class="brand">FluxTable <span style="color:#666; font-size: 0.8em;">v0.4.0</span></div>
        
        <!-- History Group (New) -->
        <div class="toolbar-group">
            <button class="btn" id="btn-undo" onclick="undo()" title="Undo (Ctrl+Z)">↶</button>
            <button class="btn" id="btn-redo" onclick="redo()" title="Redo (Ctrl+Y)">↷</button>
        </div>

        <!-- Format Group -->
        <div class="toolbar-group">
            <button class="btn" id="btn-bold" onclick="formatText('**')" title="Bold">B</button>
            <button class="btn" id="btn-italic" onclick="formatText('*')" title="Italic">I</button>
            <button class="btn" id="btn-strike" onclick="formatText('~~')" title="Strike">S</button>
            <button class="btn" id="btn-code" onclick="formatText('`')" title="Code">&lt;/&gt;</button>
        </div>

        <!-- Align Group -->
        <div class="toolbar-group">
            <button class="btn" id="btn-left" onclick="setColAlign('left')" title="Left">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M3 18h18v-2H3v2zm0-5h12v-2H3v2zm0-7v2h18V6H3z"/></svg>
            </button>
            <button class="btn" id="btn-center" onclick="setColAlign('center')" title="Center">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M3 18h18v-2H3v2zm4-5h10v-2H7v2zm-4-7v2h18V6H3z"/></svg>
            </button>
            <button class="btn" id="btn-right" onclick="setColAlign('right')" title="Right">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M3 18h18v-2H3v2zm6-5h12v-2H9v2zm-6-7v2h18V6H3z"/></svg>
            </button>
        </div>
    </div>

    <div class="toolbar-section">
        <!-- Edit Group -->
        <div class="toolbar-group">
            <button class="btn" onclick="insertRow()" title="Add Row">+ Row</button>
            <button class="btn" onclick="deleteRow()" title="Del Row" style="color:#aa4444;">×</button>
        </div>
        <div class="toolbar-group">
            <button class="btn" onclick="insertCol()" title="Add Col">+ Col</button>
            <button class="btn" onclick="deleteCol()" title="Del Col" style="color:#aa4444;">×</button>
        </div>
        
        <!-- Utility -->
        <button class="btn" style="color: var(--highlight); border:1px solid #333; background:transparent;" onclick="mockTranslate()">AUTO-TRSL</button>
        <button class="btn" style="color: #666; border:1px solid #333; background:transparent;" onclick="resetTable()" title="Clear Table">RESET</button>
        
        <div class="status-indicator">
            <div id="statusLight" class="status-dot" style="background: var(--status-green);"></div>
        </div>
    </div>
</header>

<div class="workspace">
    <!-- Left Pane: Visual -->
    <div class="pane">
        <div class="pane-header">
            <span>VISUAL GRID</span>
            <span style="font-size:0.9em; color:#444;" id="selectionInfo">No Selection</span>
        </div>
        <div class="visual-container" id="visualContainer">
            <div id="grid" class="flux-table">
                <!-- Grid items generated by JS -->
            </div>
        </div>
    </div>

    <!-- Right Pane: Code -->
    <div class="pane">
        <div class="pane-header">
            <select id="codeMode" style="background:transparent; color:#888; border:none; cursor:pointer;" onchange="switchCodeMode()">
                <option value="markdown">MARKDOWN</option>
                <option value="csv">CSV DATA</option>
            </select>
            <div class="pane-actions">
                <a class="action-link" onclick="copyCode()">COPY</a>
                <a class="action-link" onclick="downloadCode()">DOWNLOAD</a>
            </div>
        </div>
        <textarea id="codeEditor" class="code-editor" spellcheck="false"></textarea>
    </div>
</div>

<script>
    // --- FluxTable v0.4.0 Core Logic ---

    const defaultState = {
        headers: ["Component", "Specs", "Status"],
        rows: [
            ["Engine", "V8 Biturbo\n(Twin-scroll)", "**Optimal**"],
            ["Chassis", "Carbon Fiber", "In Production"]
        ],
        alignments: ["left", "left", "center"]
    };

    let appState = JSON.parse(localStorage.getItem('flux_v004')) || JSON.parse(JSON.stringify(defaultState));
    let currentFocus = { row: 0, col: 0 }; 
    let isComposing = false; // IME state lock

    // History System
    const historyStack = [];
    let historyPointer = -1;
    const MAX_HISTORY = 50;

    // DOM Elements
    const gridEl = document.getElementById('grid');
    const editorEl = document.getElementById('codeEditor');
    const statusLight = document.getElementById('statusLight');
    const selectionInfo = document.getElementById('selectionInfo');
    const btnUndo = document.getElementById('btn-undo');
    const btnRedo = document.getElementById('btn-redo');

    // Button Map
    const btnMap = {
        bold: document.getElementById('btn-bold'),
        italic: document.getElementById('btn-italic'),
        strike: document.getElementById('btn-strike'),
        code: document.getElementById('btn-code'),
        left: document.getElementById('btn-left'),
        center: document.getElementById('btn-center'),
        right: document.getElementById('btn-right'),
    };

    function init() {
        // Initialize History with current state
        pushHistory(appState, true);
        
        renderVisual();
        renderCode();
        updateToolbarState(); 
        
        // Listeners
        setupGlobalKeys();
        
        // Code Editor Sync (Debounced)
        editorEl.addEventListener('input', () => {
            if (isComposing) return;
            setStatus('syncing');
            clearTimeout(window.saveTimer);
            window.saveTimer = setTimeout(handleCodeInput, 600);
        });
    }

    // --- History Management ---
    
    function pushHistory(state, isInitial = false) {
        // Deep copy state
        const stateStr = JSON.stringify(state);
        
        // Avoid duplicate pushes (e.g., unnecessary debounces)
        if (historyPointer >= 0 && historyStack[historyPointer] === stateStr && !isInitial) {
            return; 
        }

        // If we are in middle of history, cut off future
        if (historyPointer < historyStack.length - 1) {
            historyStack.splice(historyPointer + 1);
        }

        historyStack.push(stateStr);
        if (historyStack.length > MAX_HISTORY) historyStack.shift();
        else historyPointer++;

        updateUndoRedoUI();
    }

    function undo() {
        if (historyPointer > 0) {
            historyPointer--;
            restoreStateFromHistory();
        }
    }

    function redo() {
        if (historyPointer < historyStack.length - 1) {
            historyPointer++;
            restoreStateFromHistory();
        }
    }

    function restoreStateFromHistory() {
        const stateStr = historyStack[historyPointer];
        appState = JSON.parse(stateStr);
        saveToLocal(); // persist the undo
        renderVisual();
        renderCode();
        updateToolbarState();
        updateUndoRedoUI();
    }

    function updateUndoRedoUI() {
        btnUndo.disabled = historyPointer <= 0;
        btnRedo.disabled = historyPointer >= historyStack.length - 1;
    }

    // --- State & Sync ---
    
    function updateState(newState, recordHistory = true) {
        appState = newState;
        ensureAlignmentsSync(); // Fix missing alignments bug
        saveToLocal();
        if (recordHistory) pushHistory(appState);
    }

    // Critical Fix for v0.4: Ensure alignment array matches header length
    function ensureAlignmentsSync() {
        const count = appState.headers.length;
        while(appState.alignments.length < count) appState.alignments.push('left');
        if(appState.alignments.length > count) appState.alignments = appState.alignments.slice(0, count);
    }

    function saveToLocal() {
        setStatus('syncing');
        localStorage.setItem('flux_v004', JSON.stringify(appState));
        setTimeout(() => setStatus('ready'), 200);
    }

    function setStatus(state) {
        statusLight.style.backgroundColor = state === 'syncing' ? 'var(--status-red)' : 'var(--status-green)';
    }

    // --- Visual Rendering ---
    
    function renderVisual() {
        gridEl.innerHTML = '';
        const colCount = appState.headers.length;
        gridEl.style.gridTemplateColumns = `repeat(${colCount}, minmax(100px, 1fr))`;

        // Headers
        appState.headers.forEach((text, colIndex) => {
            gridEl.appendChild(createCell(-1, colIndex, text, true));
        });

        // Body
        appState.rows.forEach((row, rowIndex) => {
            while(row.length < colCount) row.push("");
            row.forEach((text, colIndex) => {
                gridEl.appendChild(createCell(rowIndex, colIndex, text, false));
            });
        });

        restoreFocus();
    }

    function createCell(row, col, text, isHeader) {
        const cell = document.createElement('div');
        cell.className = isHeader ? 'cell cell-header' : 'cell';
        cell.contentEditable = true;
        
        // Alignment
        const align = appState.alignments[col] || 'left';
        cell.classList.add(`align-${align}`);
        if(isHeader) cell.style.textAlign = align; 

        cell.dataset.row = row;
        cell.dataset.col = col;

        const isFocused = (currentFocus.row === row && currentFocus.col === col);
        
        // Content
        if (isFocused && document.activeElement === cell) {
            cell.innerText = text;
        } else {
            cell.innerHTML = parseMarkdownToHTML(text);
        }

        // --- Events ---
        
        // IME Composition Lock (Optimized Input Experience)
        cell.addEventListener('compositionstart', () => { isComposing = true; });
        cell.addEventListener('compositionend', (e) => { 
            isComposing = false; 
            handleCellInput(e.target, row, col); // Trigger save after composition
        });

        cell.onfocus = () => {
            currentFocus = { row, col };
            // Switch to Raw Text on focus
            if (cell.innerHTML !== text) cell.innerText = appState.rows[row] ? appState.rows[row][col] : appState.headers[col];
            updateToolbarState();
            selectionInfo.innerText = isHeader ? `HEAD: ${col+1}` : `ROW: ${row+1} COL: ${col+1}`;
        };
        
        cell.onblur = () => {
             // Switch to HTML on blur
             if (cell.innerText === text) cell.innerHTML = parseMarkdownToHTML(text);
             // Push history on blur to capture the final edit state
             pushHistory(appState);
        };

        cell.oninput = (e) => {
            if (isComposing) return;
            handleCellInput(e.target, row, col);
        };

        cell.onkeydown = (e) => {
            if (e.key === 'Enter') {
                if (e.shiftKey) {
                    e.preventDefault();
                    moveFocus(1, 0);
                } else {
                    // Default behavior: inserts div/br, treated as newline
                }
            }
        };

        return cell;
    }

    function handleCellInput(target, row, col) {
        const val = target.innerText;
        
        // Update state in memory without pushing history yet (wait for blur or debounce)
        if (row === -1) appState.headers[col] = val;
        else appState.rows[row][col] = val;
        
        saveToLocal(); // Auto-save to localStorage
        renderCode(); // Sync code pane
        // Note: We don't pushHistory here to avoid cluttering stack with every char
    }

    // --- Logic & Formatting ---

    function parseMarkdownToHTML(text) {
        if (!text) return "";
        return text
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/\*\*(.*?)\*\*/g, '<span class="md-bold">$1</span>')
            .replace(/\*(.*?)\*/g, '<span class="md-italic">$1</span>')
            .replace(/~~(.*?)~~/g, '<span class="md-strike">$1</span>')
            .replace(/`(.*?)`/g, '<span class="md-code">$1</span>')
            .replace(/\n/g, '<br>');
    }

    function updateToolbarState() {
        let text = "";
        if (currentFocus.row === -1) text = appState.headers[currentFocus.col] || "";
        else if (appState.rows[currentFocus.row]) text = appState.rows[currentFocus.row][currentFocus.col] || "";

        btnMap.bold.classList.toggle('active', /\*\*.*\*\*/.test(text));
        btnMap.italic.classList.toggle('active', /\*.*\*/.test(text) && !/\*\*.*\*\*/.test(text)); 
        btnMap.strike.classList.toggle('active', /~~.*~~/.test(text));
        btnMap.code.classList.toggle('active', /`.*`/.test(text));

        const align = appState.alignments[currentFocus.col] || 'left';
        btnMap.left.classList.toggle('active', align === 'left');
        btnMap.center.classList.toggle('active', align === 'center');
        btnMap.right.classList.toggle('active', align === 'right');
    }

    function formatText(syntax) {
        const { row, col } = currentFocus;
        if (col === undefined) return;

        let val = row === -1 ? appState.headers[col] : appState.rows[row][col];
        val = val || "";

        if (val.includes(syntax)) val = val.split(syntax).join("");
        else val = syntax + val + syntax;

        if (row === -1) appState.headers[col] = val;
        else appState.rows[row][col] = val;

        updateState(appState); // Push history
        renderVisual();
        renderCode();
    }

    function setColAlign(align) {
        if (currentFocus.col === undefined) return;
        appState.alignments[currentFocus.col] = align;
        updateState(appState);
        renderVisual();
        renderCode();
    }

    // --- Structural Edits ---

    function insertRow() {
        const newRow = new Array(appState.headers.length).fill("");
        const targetIndex = currentFocus.row + 1;
        appState.rows.splice(targetIndex, 0, newRow);
        updateState(appState);
        renderVisual();
        renderCode();
    }

    function deleteRow() {
        if (currentFocus.row === -1) return;
        appState.rows.splice(currentFocus.row, 1);
        if (currentFocus.row >= appState.rows.length) currentFocus.row--;
        updateState(appState);
        renderVisual();
        renderCode();
    }

    function insertCol() {
        const targetCol = currentFocus.col + 1;
        appState.headers.splice(targetCol, 0, "New Header");
        appState.alignments.splice(targetCol, 0, "left"); // Sync fix
        appState.rows.forEach(row => row.splice(targetCol, 0, ""));
        currentFocus.col = targetCol;
        updateState(appState);
        renderVisual();
        renderCode();
    }

    function deleteCol() {
        if (appState.headers.length <= 1) return;
        appState.headers.splice(currentFocus.col, 1);
        appState.alignments.splice(currentFocus.col, 1); // Sync fix
        appState.rows.forEach(row => row.splice(currentFocus.col, 1));
        if (currentFocus.col >= appState.headers.length) currentFocus.col--;
        updateState(appState);
        renderVisual();
        renderCode();
    }

    function resetTable() {
        if(!confirm('Clear all data?')) return;
        appState = {
            headers: ["Header 1", "Header 2"],
            rows: [["", ""]],
            alignments: ["left", "left"]
        };
        currentFocus = { row: 0, col: 0 };
        updateState(appState);
        renderVisual();
        renderCode();
    }

    // --- Helpers & Keys ---

    function setupGlobalKeys() {
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                if (e.shiftKey) redo();
                else undo();
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                e.preventDefault();
                redo();
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
                e.preventDefault();
                formatText('**');
            }
        });
    }

    function restoreFocus() {
        const selector = `.cell[data-row="${currentFocus.row}"][data-col="${currentFocus.col}"]`;
        const el = document.querySelector(selector);
        if (el) el.focus();
    }

    function moveFocus(dRow, dCol) {
        currentFocus.row = Math.min(Math.max(-1, currentFocus.row + dRow), appState.rows.length - 1);
        currentFocus.col = Math.min(Math.max(0, currentFocus.col + dCol), appState.headers.length - 1);
        renderVisual(); 
    }

    // --- Code & Import/Export ---

    function renderCode() {
        const mode = document.getElementById('codeMode').value;
        let output = "";
        
        ensureAlignmentsSync(); // Safety check

        if (mode === 'markdown') {
            output += "| " + appState.headers.join(" | ") + " |\n";
            output += "|";
            // Now safely iterates based on Header count
            for(let i=0; i < appState.headers.length; i++) {
                const a = appState.alignments[i] || 'left';
                output += (a === 'center' ? " :---: |" : (a === 'right' ? " ---: |" : " :--- |"));
            }
            output += "\n";
            appState.rows.forEach(row => {
                output += "| " + row.map(c => (c||"").replace(/\n/g, "<br>")).join(" | ") + " |\n";
            });
        } else {
            output += appState.headers.join(",") + "\n";
            appState.rows.forEach(row => output += row.join(",") + "\n");
        }
        editorEl.value = output;
    }

    function handleCodeInput() {
        const lines = editorEl.value.trim().split("\n");
        const mode = document.getElementById('codeMode').value;
        
        if (mode === 'markdown') {
            const dataLines = lines.filter(l => l.includes("|") && !l.includes("---"));
            if(dataLines.length > 0) {
                const newHeaders = dataLines[0].split("|").slice(1,-1).map(s=>s.trim());
                if (newHeaders.length > 0) {
                    appState.headers = newHeaders;
                    // Reset or try to preserve alignments? Resetting is safer for pasted code
                    // But we want to preserve if possible. Let's just sync length.
                    ensureAlignmentsSync(); 
                    
                    if(dataLines.length > 1) {
                        appState.rows = dataLines.slice(1).map(l => {
                            // Basic split logic, might fail on escaped pipes
                            return l.split("|").slice(1,-1).map(s=>s.trim().replace(/<br>/g, "\n"));
                        });
                    } else {
                        appState.rows = [];
                    }
                }
            }
        }
        updateState(appState); // Save & History
        renderVisual();
    }
    
    function switchCodeMode() { renderCode(); }

    function copyCode() {
        editorEl.select();
        document.execCommand('copy');
        alert('Copied to clipboard!');
    }

    function downloadCode() {
        const text = editorEl.value;
        const mode = document.getElementById('codeMode').value;
        const ext = mode === 'markdown' ? 'md' : 'csv';
        const blob = new Blob([text], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `table.${ext}`;
        a.click();
    }

    function mockTranslate() {
        if(currentFocus.col < 0) return;
        // Snapshot before translation
        pushHistory(appState); 
        appState.rows.forEach(row => {
           if(row[currentFocus.col]) row[currentFocus.col] += " (T)";
        });
        updateState(appState);
        renderVisual();
        renderCode();
    }

    init();

</script>
</body>
</html>