<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æŸæ—å™ªè²æ¨¡æ“¬å™¨ v1.1.0 (Perlin Noise Simulator)</title>
    <!-- å¼•å…¥ p5.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #00E5FF; /* æ”¹ç‚ºæ›´å…·ç§‘æŠ€æ„Ÿçš„é’è‰² */
            --secondary-color: #2979FF;
            --border-color: #333;
            --panel-border: rgba(255,255,255,0.08);
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* å·¦å´æ§åˆ¶é¢æ¿ */
        .sidebar {
            width: 340px;
            background-color: var(--panel-bg);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 4px 0 15px rgba(0,0,0,0.4);
            z-index: 20;
        }

        /* æ»¾å‹•æ¢æ¨£å¼ */
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }
        .sidebar::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        .section {
            background: rgba(255,255,255,0.03);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid var(--panel-border);
            transition: border-color 0.3s;
        }
        
        .section:hover {
            border-color: rgba(255,255,255,0.15);
        }

        h1 {
            font-size: 1.2rem;
            margin: 0 0 15px 0;
            color: white;
            text-align: center;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(0, 229, 255, 0.3);
        }
        
        h1 span {
            color: var(--accent-color);
            font-size: 0.8em;
            display: block;
            margin-top: 5px;
        }

        h2 {
            font-size: 0.85rem;
            margin: 0 0 12px 0;
            color: var(--accent-color);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* è¡¨å–®æ§åˆ¶é … */
        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            margin-bottom: 6px;
            color: #bbb;
        }

        .value-display {
            color: var(--accent-color);
            font-weight: bold;
            font-family: monospace;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent-color);
            height: 4px;
            background: #444;
            border-radius: 2px;
            appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        input[type="text"], input[type="number"], select {
            background: #252525;
            border: 1px solid #444;
            color: white;
            padding: 8px;
            border-radius: 6px;
            width: 100%;
            box-sizing: border-box;
            font-size: 0.9rem;
        }
        
        input:focus, select:focus {
            border-color: var(--accent-color);
            outline: none;
        }

        button {
            background: linear-gradient(45deg, var(--secondary-color), #00B0FF);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 1px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
            filter: brightness(1.1);
        }
        
        button:active {
            transform: translateY(1px);
        }

        /* é–‹é—œæ¨£å¼ (Toggle Switch) */
        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 4px 0;
        }
        
        .switch {
            position: relative;
            display: inline-block;
            width: 36px;
            height: 20px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #444;
            transition: .4s;
            border-radius: 20px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--accent-color); }
        input:checked + .slider:before { transform: translateX(16px); }

        /* ä¸»ç•«å¸ƒå€åŸŸ */
        .main-content {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            background-image: 
                radial-gradient(#333 1px, transparent 1px);
            background-size: 30px 30px;
            position: relative;
            overflow: hidden;
        }

        #canvas-wrapper {
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.7);
            border: 1px solid #333;
            border-radius: 4px;
            overflow: hidden;
            /* ç¢ºä¿ç•«å¸ƒä¸æœƒå¤§æ–¼è¦–çª— */
            max-width: 95vw;
            max-height: 95vh;
        }

        /* æ¢é‡è³‡è¨Š */
        .probe-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            font-family: monospace;
            font-size: 0.9rem;
            pointer-events: none;
            backdrop-filter: blur(4px);
        }

        .tooltip-icon {
            display: inline-block;
            width: 14px;
            height: 14px;
            background: #555;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 14px;
            font-size: 10px;
            cursor: help;
            margin-left: 5px;
        }

        /* Loading */
        .loading-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            color: var(--accent-color);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(5px);
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0, 229, 255, 0.3);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- å´é‚Šæ¬„ -->
    <div class="sidebar">
        <h1>NOISE LAB <span>v1.1.0</span></h1>

        <!-- 1. æ ¸å¿ƒç”Ÿæˆ -->
        <div class="section">
            <h2>âš™ï¸ æ ¸å¿ƒç”Ÿæˆ (Core)</h2>
            
            <div class="control-group">
                <label>ç¨®å­ä»£ç¢¼ (Seed)</label>
                <div style="display:flex; gap:5px;">
                    <input type="text" id="seedInput" value="v1.1.0">
                    <button id="randomSeedBtn" style="width: 40px;">ğŸ²</button>
                </div>
            </div>

            <div class="control-group">
                <label>ç¸®æ”¾ (Scale) <span id="scaleVal" class="value-display">0.015</span></label>
                <input type="range" id="scaleSlider" min="0.002" max="0.1" step="0.001" value="0.015">
            </div>

            <div class="control-group">
                <label>ç´°ç¯€å±¤æ•¸ (Octaves) <span id="octavesVal" class="value-display">3</span></label>
                <input type="range" id="octavesSlider" min="1" max="8" step="1" value="3">
            </div>
            
            <div class="control-group">
                <label>å‹•ç•«é€Ÿåº¦ (Flow Speed) <span id="speedVal" class="value-display">0.005</span></label>
                <input type="range" id="speedSlider" min="0" max="0.03" step="0.001" value="0.005">
            </div>
        </div>

        <!-- 2. è¦–è¦ºæ¸²æŸ“ -->
        <div class="section">
            <h2>ğŸ¨ è¦–è¦ºæ¸²æŸ“ (Render)</h2>
            
            <div class="control-group">
                <label>ä¸»é¡Œ (Theme)</label>
                <select id="themeSelect">
                    <option value="terrain">â›°ï¸ åœ°å½¢ (Terrain)</option>
                    <option value="lava">ğŸ”¥ ç†”å²© (Lava)</option>
                    <option value="ocean">ğŸŒŠ æµ·æ´‹ (Ocean)</option>
                    <option value="midnight">ğŸŒŒ åˆå¤œ (Midnight)</option>
                    <option value="grayscale">âš« ç°éš (Grayscale)</option>
                </select>
            </div>
            
            <div class="toggle-row">
                <span style="font-size:0.85rem; color:#bbb;">åº•åœ–é¡¯ç¤º (Show Map)</span>
                <label class="switch">
                    <input type="checkbox" id="bgToggle" checked>
                    <span class="slider"></span>
                </label>
            </div>

            <div class="toggle-row">
                <span style="font-size:0.85rem; color:#bbb;">æ˜é¡¯åˆ†å±¤ (Stepping)</span>
                <label class="switch">
                    <input type="checkbox" id="stepToggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>

        <!-- 3. æ–°åŠŸèƒ½ï¼šå‘é‡èˆ‡ç²’å­ -->
        <div class="section" style="border-color: var(--accent-color);">
            <h2 style="color: var(--accent-color);">âœ¨ é€²éšè¦–è¦º (Vector & Flow)</h2>
            
            <div class="toggle-row">
                <span style="font-size:0.85rem; color:#bbb;">é¡¯ç¤ºå‘é‡ç¶²æ ¼ (Vector Grid)</span>
                <label class="switch">
                    <input type="checkbox" id="vectorToggle">
                    <span class="slider"></span>
                </label>
            </div>
            
            <div class="toggle-row">
                <span style="font-size:0.85rem; color:#bbb;">å•Ÿç”¨ç²’å­æµå‹• (Particles)</span>
                <label class="switch">
                    <input type="checkbox" id="particleToggle">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="control-group">
                <label>ç²’å­æ•¸é‡ (Count) <span id="pCountVal" class="value-display">1000</span></label>
                <input type="range" id="pCountSlider" min="100" max="3000" step="100" value="1000">
            </div>
            
             <div class="toggle-row">
                <span style="font-size:0.85rem; color:#bbb;">ä¿ç•™è»Œè·¡ (Trails)</span>
                <label class="switch">
                    <input type="checkbox" id="trailToggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
        </div>

        <!-- 4. åŒ¯å‡º -->
        <div class="section">
            <h2>ğŸ’¾ åŒ¯å‡º (Export)</h2>
            <div style="display:flex; gap:10px; margin-bottom:10px;">
                <input type="number" id="exportW" value="1024" placeholder="W" style="width:50%">
                <input type="number" id="exportH" value="1024" placeholder="H" style="width:50%">
            </div>
            <button id="exportBtn">ğŸ“¸ ç”Ÿæˆé«˜ç•«è³ªåœ–ç‰‡</button>
        </div>
    </div>

    <!-- ä¸»ç•«å¸ƒ -->
    <div class="main-content">
        <div id="canvas-wrapper">
            <!-- P5 Canvas Here -->
        </div>
        
        <!-- æ¢é‡é¡¯ç¤º -->
        <div id="probeInfo" class="probe-info" style="display:none;">
            X: 0 | Y: 0 | H: 0.00
        </div>

        <!-- Loading -->
        <div id="loadingOverlay" class="loading-overlay">
            <div class="loading-spinner"></div>
            <div>è™•ç†é«˜ç•«è³ªé‹ç®—ä¸­...</div>
        </div>
    </div>

    <script>
        // === åƒæ•¸èˆ‡ç‹€æ…‹ ===
        let params = {
            seed: 'v1.1.0',
            scale: 0.015,
            octaves: 3,
            persistence: 0.5,
            lacunarity: 2.0,
            speed: 0.005,
            theme: 'terrain',
            showBg: true,
            stepping: false,
            showVectors: false,
            showParticles: false,
            particleCount: 1000,
            trails: true,
            zOff: 0 // æ™‚é–“ç¶­åº¦
        };

        let mainCanvas;
        let particles = [];
        let flowField = []; // å„²å­˜å‘é‡å ´è§’åº¦
        let cols, rows;
        let scl = 20; // å‘é‡ç¶²æ ¼çš„å–®å…ƒå¤§å° (px)
        const PREVIEW_SIZE = 600;

        // === P5.js Setup ===
        function setup() {
            let wrapper = document.getElementById('canvas-wrapper');
            mainCanvas = createCanvas(PREVIEW_SIZE, PREVIEW_SIZE);
            mainCanvas.parent('canvas-wrapper');
            
            updateSeed();
            initParticles();
            initUI();
            
            background(0);
        }

        // === P5.js Draw ===
        function draw() {
            // 1. å¦‚æœé–‹å•Ÿè»Œè·¡ï¼Œä½¿ç”¨åŠé€æ˜èƒŒæ™¯ç”¢ç”Ÿæ®˜å½±ï¼›å¦å‰‡å®Œå…¨é‡ç¹ª
            if (params.showParticles && params.trails) {
                background(0, 20); // æ·¡å‡ºæ•ˆæœ
            } else if (params.showBg) {
                // å¦‚æœéœ€è¦ç¹ªè£½åº•åœ–ï¼Œé€™è£¡ä¸ä½¿ç”¨ background(0)ï¼Œè€Œæ˜¯è®“ renderBackground å¡«æ»¿
                // ä½†ç‚ºäº†æ€§èƒ½ï¼Œæˆ‘å€‘åœ¨ renderBackground å…§éƒ¨è™•ç†
            } else {
                background(0); // ç´”é»‘èƒŒæ™¯
            }

            // æ›´æ–°æ™‚é–“
            params.zOff += params.speed;

            // 2. ç¹ªè£½åº•å±¤å™ªè²åœ– (Heatmap)
            // ç‚ºäº†å„ªåŒ–æ€§èƒ½ï¼Œå¦‚æœåªçœ‹ç²’å­ï¼Œå¯ä»¥é—œé–‰åº•åœ–ï¼Œæˆ–è€…é™ä½åº•åœ–åˆ·æ–°ç‡
            if (params.showBg) {
                renderBackground();
            }

            // 3. è¨ˆç®—ä¸¦ç¹ªè£½å‘é‡ç¶²æ ¼ / æ›´æ–°æµå‹•å ´
            if (params.showVectors || params.showParticles) {
                updateFlowField();
            }

            // 4. ç¹ªè£½ç²’å­
            if (params.showParticles) {
                updateAndShowParticles();
            }

            // 5. æ»‘é¼ æ¢é‡ (UI)
            updateProbe();
        }

        // === æ ¸å¿ƒï¼šç¹ªè£½åº•å±¤å™ªè² ===
        function renderBackground() {
            loadPixels();
            let d = pixelDensity();
            
            // å„ªåŒ–ï¼šå¦‚æœé–‹äº†ç²’å­ä¸”æœ‰è»Œè·¡ï¼Œä¸è¦æ¯å¹€é‡ç¹ªæ•´å€‹åº•åœ–ï¼Œæœƒè“‹æ‰è»Œè·¡
            // ä½†å¦‚æœä½¿ç”¨è€…æƒ³çœ‹åº•åœ–+ç²’å­ï¼Œæˆ‘å€‘éœ€è¦ç­–ç•¥ã€‚
            // v1.1.0 ç­–ç•¥ï¼šå¦‚æœ Trails é–‹å•Ÿï¼Œåº•åœ–åªç¹ªè£½ä¸€æ¬¡æˆ–æ·¡å‡ºï¼Ÿ
            // å¯¦éš›ä¸Šï¼Œå¦‚æœ Trails é–‹å•Ÿï¼Œåº•åœ–æœƒåš´é‡å¹²æ“¾æ®˜å½±ã€‚
            // è®“æˆ‘å€‘å…ˆç°¡å–®è™•ç†ï¼šå¦‚æœ Trails é–‹å•Ÿï¼Œå¼·åˆ¶ä¸ç¹ªè£½åº•åœ–ï¼Œæˆ–è€…ç•«åœ¨æœ€åº•å±¤è¢«åŠé€æ˜è“‹é
            
            if (params.showParticles && params.trails) {
                // åœ¨è»Œè·¡æ¨¡å¼ä¸‹ï¼Œæˆ‘å€‘ä¸ç¹ªè£½åº•åœ–ï¼Œåªç¹ªè£½åŠé€æ˜é»‘å±¤ (åœ¨ draw é–‹é ­å·²åš)
                return; 
            }

            // æ¨™æº–ç¹ªè£½
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let noiseVal = getNoiseValue(x, y);
                    
                    // Stepping
                    if (params.stepping) {
                        noiseVal = Math.floor(noiseVal * 10) / 9;
                    }

                    let c = getThemeColor(noiseVal, params.theme);
                    
                    let index = (x + y * width) * 4;
                    pixels[index] = red(c);
                    pixels[index + 1] = green(c);
                    pixels[index + 2] = blue(c);
                    pixels[index + 3] = 255;
                }
            }
            updatePixels();
        }

        // === æ ¸å¿ƒï¼šè¨ˆç®—å‘é‡å ´ (Flow Field) ===
        function updateFlowField() {
            cols = floor(width / scl);
            rows = floor(height / scl);
            flowField = new Array(cols * rows);

            if (params.showVectors) {
                stroke(255, 100);
                strokeWeight(1);
            }

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    let xPixel = x * scl;
                    let yPixel = y * scl;
                    
                    // ç²å–è©²ç¶²æ ¼ä¸­å¿ƒçš„å™ªè²å€¼
                    let noiseVal = getNoiseValue(xPixel, yPixel);
                    
                    // å°‡ 0-1 çš„å™ªè²å€¼æ˜ å°„åˆ° 0-4PI (å…©åœˆï¼Œå¢åŠ æ—‹è½‰æ„Ÿ)
                    let angle = noiseVal * TWO_PI * 2; // å…©åœˆæ¯”è¼ƒæœ‰æµå‹•æ„Ÿ
                    
                    // å­˜å…¥æµå‹•å ´é™£åˆ— (çµ¦ç²’å­ç”¨)
                    let index = x + y * cols;
                    flowField[index] = createVector(cos(angle), sin(angle));

                    // ç¹ªè£½å‘é‡ç¶²æ ¼ (å¦‚æœé–‹å•Ÿ)
                    if (params.showVectors) {
                        push();
                        translate(xPixel + scl/2, yPixel + scl/2);
                        rotate(angle);
                        let len = scl * 0.8;
                        stroke(getThemeColor(noiseVal, params.theme)); // è®“ç®­é ­ä¹Ÿæœ‰é¡è‰²
                        line(0, 0, len, 0);
                        // ç•«ç®­é ­é ­éƒ¨
                        // line(len, 0, len-3, -3);
                        // line(len, 0, len-3, 3);
                        pop();
                    }
                }
            }
        }

        // === æ ¸å¿ƒï¼šç²’å­ç³»çµ± ===
        function initParticles() {
            particles = [];
            for (let i = 0; i < params.particleCount; i++) {
                particles.push(new Particle());
            }
        }

        function updateAndShowParticles() {
            for (let p of particles) {
                p.follow(flowField);
                p.update();
                p.edges();
                p.show();
            }
        }

        class Particle {
            constructor() {
                this.pos = createVector(random(width), random(height));
                this.vel = createVector(0, 0);
                this.acc = createVector(0, 0);
                this.maxSpeed = 2; // ç²’å­é€Ÿåº¦
                this.prevPos = this.pos.copy();
                
                // æ¯å€‹ç²’å­æœ‰éš¨æ©Ÿé¡è‰²åç§»ï¼Œå¢åŠ è¦–è¦ºè±å¯Œåº¦
                this.colorOffset = random(0.8, 1.2);
            }

            follow(vectors) {
                let x = floor(this.pos.x / scl);
                let y = floor(this.pos.y / scl);
                let index = x + y * cols;
                
                // å®‰å…¨æª¢æŸ¥
                if(index >= 0 && index < vectors.length && vectors[index]) {
                    let force = vectors[index];
                    this.applyForce(force);
                }
            }

            applyForce(force) {
                this.acc.add(force);
            }

            update() {
                this.vel.add(this.acc);
                this.vel.limit(this.maxSpeed);
                this.pos.add(this.vel);
                this.acc.mult(0);
            }

            show() {
                // æ ¹æ“šç•¶å‰ä½ç½®çš„å™ªè²å€¼æ±ºå®šé¡è‰²
                let noiseVal = getNoiseValue(this.pos.x, this.pos.y);
                let c = getThemeColor(noiseVal, params.theme);
                
                stroke(red(c), green(c), blue(c), params.trails ? 150 : 255);
                strokeWeight(params.trails ? 1 : 2);
                
                if (params.trails) {
                    line(this.pos.x, this.pos.y, this.prevPos.x, this.prevPos.y);
                    this.updatePrev();
                } else {
                    point(this.pos.x, this.pos.y);
                }
            }

            updatePrev() {
                this.prevPos.x = this.pos.x;
                this.prevPos.y = this.pos.y;
            }

            edges() {
                if (this.pos.x > width) { this.pos.x = 0; this.updatePrev(); }
                if (this.pos.x < 0) { this.pos.x = width; this.updatePrev(); }
                if (this.pos.y > height) { this.pos.y = 0; this.updatePrev(); }
                if (this.pos.y < 0) { this.pos.y = height; this.updatePrev(); }
            }
        }

        // === å·¥å…·ï¼šå–å¾—åˆ†å½¢å™ªè²å€¼ ===
        function getNoiseValue(x, y) {
            let total = 0;
            let amplitude = 1;
            let frequency = params.scale;
            let maxValue = 0;

            // ä½¿ç”¨ç°¡å–®çš„ç–ŠåŠ ç®—æ³•
            for (let i = 0; i < params.octaves; i++) {
                total += noise(x * frequency, y * frequency, params.zOff) * amplitude;
                maxValue += amplitude;
                amplitude *= params.persistence;
                frequency *= params.lacunarity;
            }
            
            return total / maxValue;
        }

        // === å·¥å…·ï¼šé¡è‰²ä¸»é¡Œ ===
        function getThemeColor(val, theme) {
            // åˆå¤œ Neon Theme
            if (theme === 'midnight') {
                 if (val < 0.3) return color(10, 0, 30);
                 if (val < 0.5) return lerpColor(color(10, 0, 30), color(100, 0, 150), map(val,0.3,0.5,0,1));
                 if (val < 0.7) return lerpColor(color(100, 0, 150), color(0, 200, 255), map(val,0.5,0.7,0,1));
                 return lerpColor(color(0, 200, 255), color(255, 255, 255), map(val,0.7,1,0,1));
            }
            // ç°éš
            if (theme === 'grayscale') return color(val * 255);
            
            // åœ°å½¢
            if (theme === 'terrain') {
                if (val < 0.3) return color(10, 30, 80);
                if (val < 0.45) return color(30, 80, 200);
                if (val < 0.5) return color(210, 180, 140);
                if (val < 0.65) return color(34, 139, 34);
                if (val < 0.8) return color(100, 100, 100);
                return color(255);
            }
            
            // ç†”å²©
            if (theme === 'lava') {
                if (val < 0.3) return color(20, 5, 5);
                if (val < 0.6) return lerpColor(color(20, 5, 5), color(255, 60, 0), map(val, 0.3, 0.6, 0, 1));
                return lerpColor(color(255, 60, 0), color(255, 255, 0), map(val, 0.6, 1, 0, 1));
            }
            
            // æµ·æ´‹
            if (theme === 'ocean') {
                 if (val < 0.5) return lerpColor(color(0,0,50), color(0,100,200), map(val,0,0.5,0,1));
                 return lerpColor(color(0,100,200), color(150,255,255), map(val,0.5,1,0,1));
            }

            return color(255);
        }

        // === UI äº¤äº’ ===
        function updateProbe() {
            if (mouseX >= 0 && mouseX < width && mouseY >= 0 && mouseY < height) {
                let n = getNoiseValue(mouseX, mouseY).toFixed(2);
                let el = document.getElementById('probeInfo');
                el.style.display = 'block';
                el.innerHTML = `X: ${floor(mouseX)} | Y: ${floor(mouseY)} | Value: <span style="color:white">${n}</span>`;
            } else {
                document.getElementById('probeInfo').style.display = 'none';
            }
        }

        function initUI() {
            // Helper
            const bind = (id, key, displayId) => {
                document.getElementById(id).addEventListener('input', (e) => {
                    let val = parseFloat(e.target.value);
                    params[key] = val;
                    if (displayId) document.getElementById(displayId).innerText = val;
                });
            };

            // Core
            bind('scaleSlider', 'scale', 'scaleVal');
            bind('octavesSlider', 'octaves', 'octavesVal');
            bind('speedSlider', 'speed', 'speedVal');
            
            // Toggles
            const bindCheck = (id, key) => {
                document.getElementById(id).addEventListener('change', (e) => params[key] = e.target.checked);
            };
            bindCheck('bgToggle', 'showBg');
            bindCheck('stepToggle', 'stepping');
            bindCheck('vectorToggle', 'showVectors');
            bindCheck('trailToggle', 'trails');

            // ç²’å­é–‹é—œç‰¹åˆ¥è™•ç†
            document.getElementById('particleToggle').addEventListener('change', (e) => {
                params.showParticles = e.target.checked;
                if(params.showParticles && particles.length === 0) initParticles();
            });

            // ç²’å­æ•¸é‡
            document.getElementById('pCountSlider').addEventListener('input', (e) => {
                params.particleCount = parseInt(e.target.value);
                document.getElementById('pCountVal').innerText = params.particleCount;
                initParticles(); // é‡ç½®ç²’å­
            });

            // Theme
            document.getElementById('themeSelect').addEventListener('change', (e) => params.theme = e.target.value);

            // Seed
            const updateSeed = () => {
                let str = document.getElementById('seedInput').value;
                let val = 0;
                for(let i=0; i<str.length; i++) val += str.charCodeAt(i);
                noiseSeed(val);
                params.zOff = 0;
                initParticles(); // é‡ç½®ç²’å­é˜²æ­¢å¡åœ¨å¥‡æ€ªåœ°æ–¹
                background(0); // æ¸…ç©ºç•«é¢
            };
            
            document.getElementById('seedInput').addEventListener('input', updateSeed);
            document.getElementById('randomSeedBtn').addEventListener('click', () => {
                document.getElementById('seedInput').value = Math.floor(Math.random()*100000);
                updateSeed();
            });

            // Export
            document.getElementById('exportBtn').addEventListener('click', exportImage);
        }

        function updateSeed() {
             let str = document.getElementById('seedInput').value;
             let val = 0;
             for(let i=0; i<str.length; i++) val += str.charCodeAt(i);
             noiseSeed(val);
        }

        // === åŒ¯å‡ºé‚è¼¯ (ç°¡åŒ–ç‰ˆ) ===
        function exportImage() {
            let w = parseInt(document.getElementById('exportW').value);
            let h = parseInt(document.getElementById('exportH').value);
            
            document.getElementById('loadingOverlay').style.display = 'flex';
            
            setTimeout(() => {
                let pg = createGraphics(w, h);
                pg.pixelDensity(1);
                pg.background(0);
                
                // ç‚ºäº†åŒ¯å‡ºï¼Œæˆ‘å€‘åªç•«åº•åœ–ï¼Œå› ç‚ºç²’å­æ˜¯å‹•æ…‹çš„ï¼Œå¾ˆé›£æ•æ‰"ä¸€ç¬é–“"çš„æµå‹•æ„Ÿæˆéœæ…‹åœ–
                // é™¤éæˆ‘å€‘æ¨¡æ“¬è·‘å¹¾ç™¾å¹€ã€‚v1.1.0 å…ˆåªæ”¯æ´åŒ¯å‡ºé«˜æ¸…åº•åœ–ã€‚
                
                pg.loadPixels();
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        // èª¿æ•´ scale æ¯”ä¾‹ä»¥ç¬¦åˆé è¦½çš„è¦–é‡
                        let nx = x * (PREVIEW_SIZE/w);
                        let ny = y * (PREVIEW_SIZE/h);
                        
                        let n = getNoiseValue(nx, ny); // æ³¨æ„é€™è£¡ç”¨ nx, ny
                        if (params.stepping) n = Math.floor(n*10)/9;
                        
                        let c = getThemeColor(n, params.theme);
                        pg.set(x, y, c);
                    }
                }
                pg.updatePixels();
                
                save(pg, `noise_${params.seed}_${params.theme}`, 'png');
                pg.remove();
                document.getElementById('loadingOverlay').style.display = 'none';
            }, 100);
        }

    </script>
</body>
</html>
