<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æŸæ—å™ªè²æ¨¡æ“¬å™¨ v1.2.0 (Perlin Noise Simulator)</title>
    <!-- å¼•å…¥ p5.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #00E5FF; /* é’è‰² */
            --secondary-color: #2979FF;
            --border-color: #333;
            --panel-border: rgba(255,255,255,0.08);
            --info-color: #FFC107; /* æç¤ºé»ƒè‰² */
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* å·¦å´æ§åˆ¶é¢æ¿ */
        .sidebar {
            width: 340px;
            background-color: var(--panel-bg);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 4px 0 15px rgba(0,0,0,0.4);
            z-index: 20;
        }

        /* æ»¾å‹•æ¢æ¨£å¼ */
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }
        .sidebar::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        .section {
            background: rgba(255,255,255,0.03);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid var(--panel-border);
            transition: border-color 0.3s;
        }
        
        .section:hover {
            border-color: rgba(255,255,255,0.15);
        }

        h1 {
            font-size: 1.2rem;
            margin: 0 0 15px 0;
            color: white;
            text-align: center;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(0, 229, 255, 0.3);
        }
        
        h1 span {
            color: var(--accent-color);
            font-size: 0.8em;
            display: block;
            margin-top: 5px;
        }

        h2 {
            font-size: 0.85rem;
            margin: 0 0 12px 0;
            color: var(--accent-color);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* è¡¨å–®æ§åˆ¶é … */
        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            margin-bottom: 6px;
            color: #bbb;
        }

        .value-display {
            color: var(--accent-color);
            font-weight: bold;
            font-family: monospace;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent-color);
            height: 4px;
            background: #444;
            border-radius: 2px;
            appearance: none;
        }
        
        /* Tooltip Style */
        .tooltip-container {
            position: relative;
            display: inline-block;
        }
        .tooltip-icon {
            display: inline-flex;
            width: 16px;
            height: 16px;
            background: var(--info-color);
            color: #121212;
            border-radius: 50%;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            cursor: help;
            margin-left: 5px;
            transition: transform 0.2s;
        }
        .tooltip-icon:hover {
            transform: scale(1.1);
        }
        .tooltip-text {
            visibility: hidden;
            width: 250px;
            background-color: #2c2c2c;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px 12px;
            position: absolute;
            z-index: 10;
            bottom: 100%;
            left: 50%;
            margin-left: -125px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
            line-height: 1.4;
            border: 1px solid var(--info-color);
        }
        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: var(--info-color) transparent transparent transparent;
        }
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* ä¸»ç•«å¸ƒå€åŸŸ */
        .main-content {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            background-image: 
                radial-gradient(#333 1px, transparent 1px);
            background-size: 30px 30px;
            position: relative;
            overflow: hidden;
        }

        #canvas-wrapper {
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.7);
            border: 1px solid #333;
            border-radius: 4px;
            overflow: hidden;
            max-width: 95vw;
            max-height: 95vh;
        }

        /* æ¢é‡è³‡è¨Š */
        .probe-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            font-family: monospace;
            font-size: 0.9rem;
            pointer-events: none;
            backdrop-filter: blur(4px);
        }

        /* Loading */
        .loading-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            color: var(--accent-color);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(5px);
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0, 229, 255, 0.3);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- å´é‚Šæ¬„ -->
    <div class="sidebar">
        <h1>NOISE LAB <span>v1.2.0</span></h1>

        <!-- 1. æ ¸å¿ƒç”Ÿæˆ -->
        <div class="section">
            <h2>âš™ï¸ æ ¸å¿ƒç”Ÿæˆ (Core)</h2>
            
            <div class="control-group">
                <label>ç¨®å­ä»£ç¢¼ (Seed)</label>
                <div style="display:flex; gap:5px;">
                    <input type="text" id="seedInput" value="v1.2.0">
                    <button id="randomSeedBtn" style="width: 40px;">ğŸ²</button>
                </div>
            </div>

            <div class="control-group">
                <label>ç¸®æ”¾ (Scale) <span id="scaleVal" class="value-display">0.015</span></label>
                <input type="range" id="scaleSlider" min="0.002" max="0.1" step="0.001" value="0.015">
            </div>

            <!-- Octaves with Tooltip -->
            <div class="control-group">
                <label>
                    å…«åº¦å±¤æ•¸ (Octaves)
                    <div class="tooltip-container">
                        <span class="tooltip-icon">?</span>
                        <span class="tooltip-text">
                            ç”¨æ–¼ç”Ÿæˆå™ªè²çš„åˆ†å±¤æ•¸é‡ã€‚å±¤æ•¸è¶Šå¤šï¼Œç´°ç¯€è¶Šè±å¯Œï¼Œåœ–å½¢è¶Šè‡ªç„¶ï¼Œä½†è¨ˆç®—æˆæœ¬è¶Šé«˜ã€‚
                        </span>
                    </div>
                    <span id="octavesVal" class="value-display">3</span>
                </label>
                <input type="range" id="octavesSlider" min="1" max="8" step="1" value="3">
            </div>
            
            <!-- Persistence with Tooltip -->
            <div class="control-group">
                <label>
                    æŒçºŒåº¦ (Persistence)
                    <div class="tooltip-container">
                        <span class="tooltip-icon">?</span>
                        <span class="tooltip-text">
                            æ§åˆ¶å¾ŒçºŒç´°ç¯€å±¤çš„å½±éŸ¿åŠ›è¡°æ¸›é€Ÿåº¦ (0-1)ã€‚å€¼è¶Šé«˜ï¼Œç´°ç¯€å±¤å½±éŸ¿è¶Šå¤§ï¼Œåœ°å½¢æœƒæ›´å°–éŠ³ã€é«˜ä½è½å·®å¤§ã€‚
                        </span>
                    </div>
                    <span id="persistenceVal" class="value-display">0.50</span>
                </label>
                <input type="range" id="persistenceSlider" min="0.1" max="1.0" step="0.01" value="0.5">
            </div>

            <!-- Lacunarity with Tooltip -->
            <div class="control-group">
                <label>
                    é–“éš™åº¦ (Lacunarity)
                    <div class="tooltip-container">
                        <span class="tooltip-icon">?</span>
                        <span class="tooltip-text">
                            æ§åˆ¶å¾ŒçºŒç´°ç¯€å±¤çš„é »ç‡å¢åŠ é€Ÿåº¦ (>1)ã€‚å€¼è¶Šé«˜ï¼Œæ¯ä¸€å±¤ä¹‹é–“çš„ç´°ç¯€å°ºåº¦å·®ç•°è¶Šå¤§ã€‚é€šå¸¸è¨­ç‚º 2.0ã€‚
                        </span>
                    </div>
                    <span id="lacunarityVal" class="value-display">2.00</span>
                </label>
                <input type="range" id="lacunaritySlider" min="1.5" max="3.0" step="0.01" value="2.0">
            </div>

            <div class="control-group">
                <label>å‹•ç•«é€Ÿåº¦ (Flow Speed) <span id="speedVal" class="value-display">0.005</span></label>
                <input type="range" id="speedSlider" min="0" max="0.03" step="0.001" value="0.005">
            </div>
        </div>

        <!-- 2. è¦–è¦ºæ¸²æŸ“ -->
        <div class="section">
            <h2>ğŸ¨ è¦–è¦ºæ¸²æŸ“ (Render)</h2>
            
            <div class="control-group">
                <label>ä¸»é¡Œ (Theme)</label>
                <select id="themeSelect">
                    <option value="terrain">â›°ï¸ åœ°å½¢ (Terrain)</option>
                    <option value="ocean">ğŸŒŠ æµ·æ´‹ (Ocean)</option>
                    <option value="lava">ğŸ”¥ ç†”å²© (Lava)</option>
                    <option value="midnight">ğŸŒŒ åˆå¤œ (Midnight)</option>
                    <option value="rainbow">ğŸŒˆ å½©è™¹ (Rainbow)</option>
                    <option value="grayscale">âš« ç°éš (Grayscale)</option>
                </select>
            </div>
            
            <div class="toggle-row">
                <span style="font-size:0.85rem; color:#bbb;">åº•åœ–é¡¯ç¤º (Show Map)</span>
                <label class="switch">
                    <input type="checkbox" id="bgToggle" checked>
                    <span class="slider"></span>
                </label>
            </div>

            <div class="control-group">
                 <label>åˆ†å±¤æ•¸é‡ (Step Count) <span id="stepCountVal" class="value-display">10</span></label>
                 <input type="range" id="stepCountSlider" min="2" max="50" step="1" value="10">
            </div>
            <div class="toggle-row">
                <span style="font-size:0.85rem; color:#bbb;">å•Ÿç”¨åˆ†å±¤ (Stepping)</span>
                <label class="switch">
                    <input type="checkbox" id="stepToggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>

        <!-- 3. æ–°åŠŸèƒ½ï¼šå‘é‡èˆ‡ç²’å­ -->
        <div class="section" style="border-color: var(--accent-color);">
            <h2 style="color: var(--accent-color);">âœ¨ é€²éšè¦–è¦º (Vector & Flow)</h2>
            
            <div class="toggle-row">
                <span style="font-size:0.85rem; color:#bbb;">é¡¯ç¤ºå‘é‡ç¶²æ ¼ (Vector Grid)</span>
                <label class="switch">
                    <input type="checkbox" id="vectorToggle">
                    <span class="slider"></span>
                </label>
            </div>
            
            <div class="control-group">
                <label>å‘é‡ç¶²æ ¼å¤§å° (Grid Size) <span id="gridSizeVal" class="value-display">20</span></label>
                <input type="range" id="gridSizeSlider" min="10" max="50" step="5" value="20">
            </div>

            <div class="toggle-row">
                <span style="font-size:0.85rem; color:#bbb;">å•Ÿç”¨ç²’å­æµå‹• (Particles)</span>
                <label class="switch">
                    <input type="checkbox" id="particleToggle">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="control-group">
                <label>ç²’å­æ•¸é‡ (Count) <span id="pCountVal" class="value-display">1000</span></label>
                <input type="range" id="pCountSlider" min="100" max="3000" step="100" value="1000">
            </div>
            
             <div class="toggle-row">
                <span style="font-size:0.85rem; color:#bbb;">ä¿ç•™è»Œè·¡ (Trails)</span>
                <label class="switch">
                    <input type="checkbox" id="trailToggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
        </div>

        <!-- 4. åŒ¯å‡º -->
        <div class="section">
            <h2>ğŸ’¾ åŒ¯å‡º (Export)</h2>
            <div style="display:flex; gap:10px; margin-bottom:10px;">
                <input type="number" id="exportW" value="1024" placeholder="W" style="width:50%">
                <input type="number" id="exportH" value="1024" placeholder="H" style="width:50%">
            </div>
            <button id="exportBtn">ğŸ“¸ ç”Ÿæˆé«˜ç•«è³ªåœ–ç‰‡</button>
        </div>
    </div>

    <!-- ä¸»ç•«å¸ƒ -->
    <div class="main-content">
        <div id="canvas-wrapper">
            <!-- P5 Canvas Here -->
        </div>
        
        <!-- æ¢é‡é¡¯ç¤º -->
        <div id="probeInfo" class="probe-info" style="display:none;">
            X: 0 | Y: 0 | Value: <span style="color:white">0.00</span>
        </div>

        <!-- Loading -->
        <div id="loadingOverlay" class="loading-overlay">
            <div class="loading-spinner"></div>
            <div>è™•ç†é«˜ç•«è³ªé‹ç®—ä¸­...</div>
        </div>
    </div>

    <script>
        // === åƒæ•¸èˆ‡ç‹€æ…‹ ===
        let params = {
            seed: 'v1.2.0',
            scale: 0.015,
            octaves: 3,
            persistence: 0.5,
            lacunarity: 2.0,
            speed: 0.005,
            theme: 'terrain',
            showBg: true,
            stepping: false,
            stepCount: 10,
            showVectors: false,
            gridSize: 20,
            showParticles: false,
            particleCount: 1000,
            trails: true,
            zOff: 0
        };

        let mainCanvas;
        let particles = [];
        let flowField = []; 
        let cols, rows;
        const PREVIEW_SIZE = 600;

        // === P5.js Setup ===
        function setup() {
            let wrapper = document.getElementById('canvas-wrapper');
            mainCanvas = createCanvas(PREVIEW_SIZE, PREVIEW_SIZE);
            mainCanvas.parent('canvas-wrapper');
            
            colorMode(RGB, 255); 
            
            // Fix: updateSeed å·²ç¶“æ˜¯å…¨åŸŸå‡½æ•¸ï¼Œé€™è£¡å¯ä»¥å®‰å…¨èª¿ç”¨
            updateSeed(); 
            initParticles();
            initUI();
            
            background(0);
        }

        // === P5.js Draw ===
        function draw() {
            if (params.showParticles && params.trails) {
                background(0, 20); 
            } else if (params.showBg) {
                // Background handled by renderBackground
            } else {
                background(0); 
            }

            params.zOff += params.speed;

            if (params.showBg && !(params.showParticles && params.trails)) {
                renderBackground(width, height, getNoiseValue);
            }

            if (params.showVectors || params.showParticles) {
                updateFlowField();
            }

            if (params.showParticles) {
                updateAndShowParticles();
            }

            updateProbe();
        }

        // === å…¨åŸŸåŠŸèƒ½å‡½æ•¸: æ›´æ–°ç¨®å­ ===
        // å°‡ updateSeed ç§»åˆ°å…¨åŸŸç¯„åœï¼Œè§£æ±º setup() æ‰¾ä¸åˆ°å‡½æ•¸çš„å•é¡Œ
        function updateSeed() {
            let str = document.getElementById('seedInput').value;
            let val = 0;
            for(let i=0; i<str.length; i++) val += str.charCodeAt(i);
            
            noiseSeed(val);
            randomSeed(val); // ä¹Ÿé‡ç½®éš¨æ©Ÿæ•¸ç¨®å­
            
            params.zOff = 0;
            initParticles(); // é‡ç½®ç²’å­ä½ç½®
            background(0);   // æ¸…ç©ºç•«é¢
        }

        function renderBackground(w, h, noiseFunc) {
            loadPixels();
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    let noiseVal = noiseFunc(x, y);
                    if (params.stepping) {
                        noiseVal = floor(noiseVal * params.stepCount) / (params.stepCount - 1);
                    }
                    let c = getThemeColor(noiseVal, params.theme);
                    let index = (x + y * width) * 4;
                    pixels[index] = red(c);
                    pixels[index + 1] = green(c);
                    pixels[index + 2] = blue(c);
                    pixels[index + 3] = 255;
                }
            }
            updatePixels();
        }

        function updateFlowField() {
            let scl = params.gridSize;
            cols = floor(width / scl);
            rows = floor(height / scl);
            flowField = new Array(cols * rows);

            if (params.showVectors) {
                noFill();
                stroke(255, 150); 
                strokeWeight(1);
            }

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    let xPixel = x * scl;
                    let yPixel = y * scl;
                    let noiseVal = getNoiseValue(xPixel, yPixel);
                    let angle = map(noiseVal, 0, 1, 0, TWO_PI * 2); 
                    
                    let index = x + y * cols;
                    flowField[index] = p5.Vector.fromAngle(angle);

                    if (params.showVectors) {
                        push();
                        translate(xPixel + scl/2, yPixel + scl/2);
                        rotate(angle);
                        let len = scl * 0.8;
                        stroke(getThemeColor(noiseVal, params.theme)); 
                        line(0, 0, len, 0);
                        pop();
                    }
                }
            }
        }

        function initParticles() {
            particles = [];
            for (let i = 0; i < params.particleCount; i++) {
                particles.push(new Particle());
            }
        }

        function updateAndShowParticles() {
            for (let p of particles) {
                p.follow(flowField);
                p.update();
                p.edges();
                p.show();
            }
        }

        class Particle {
            constructor() {
                this.pos = createVector(random(width), random(height));
                this.vel = createVector(0, 0);
                this.acc = createVector(0, 0);
                this.maxSpeed = 2; 
                this.prevPos = this.pos.copy();
            }

            follow(vectors) {
                let scl = params.gridSize;
                let x = floor(this.pos.x / scl);
                let y = floor(this.pos.y / scl);
                let index = x + y * cols;
                
                if(index >= 0 && index < vectors.length && vectors[index]) {
                    let force = vectors[index].copy().mult(0.5);
                    this.applyForce(force);
                }
            }

            applyForce(force) {
                this.acc.add(force);
            }

            update() {
                this.vel.add(this.acc);
                this.vel.limit(this.maxSpeed);
                this.pos.add(this.vel);
                this.acc.mult(0);
            }

            show() {
                let noiseVal = getNoiseValue(this.pos.x, this.pos.y);
                let c = getThemeColor(noiseVal, params.theme);
                
                stroke(red(c), green(c), blue(c), params.trails ? 150 : 255);
                strokeWeight(params.trails ? 1 : 2);
                
                if (params.trails) {
                    line(this.pos.x, this.pos.y, this.prevPos.x, this.prevPos.y);
                    this.updatePrev();
                } else {
                    point(this.pos.x, this.pos.y);
                }
            }

            updatePrev() {
                this.prevPos.x = this.pos.x;
                this.prevPos.y = this.pos.y;
            }

            edges() {
                if (this.pos.x > width) { this.pos.x = 0; this.updatePrev(); }
                if (this.pos.x < 0) { this.pos.x = width; this.updatePrev(); }
                if (this.pos.y > height) { this.pos.y = 0; this.updatePrev(); }
                if (this.pos.y < 0) { this.pos.y = height; this.updatePrev(); }
            }
        }

        function getNoiseValue(x, y) {
            let total = 0;
            let amplitude = 1;
            let frequency = params.scale;
            let maxValue = 0;

            for (let i = 0; i < params.octaves; i++) {
                total += noise(x * frequency, y * frequency, params.zOff * frequency) * amplitude; 
                maxValue += amplitude;
                amplitude *= params.persistence;
                frequency *= params.lacunarity;
            }
            
            return total / maxValue;
        }

        function getThemeColor(val, theme) {
            if (theme === 'rainbow') {
                colorMode(HSB, 360, 100, 100);
                let h = map(val, 0, 1, 0, 360);
                let c = color(h, 90, 90);
                colorMode(RGB, 255);
                return c;
            }
            if (theme === 'midnight') {
                 colorMode(RGB, 255);
                 if (val < 0.3) return color(10, 0, 30);
                 if (val < 0.5) return lerpColor(color(10, 0, 30), color(100, 0, 150), map(val,0.3,0.5,0,1));
                 if (val < 0.7) return lerpColor(color(100, 0, 150), color(0, 200, 255), map(val,0.5,0.7,0,1));
                 return lerpColor(color(0, 200, 255), color(255, 255, 255), map(val,0.7,1,0,1));
            }
            if (theme === 'grayscale') { colorMode(RGB, 255); return color(val * 255); }
            if (theme === 'terrain') {
                colorMode(RGB, 255);
                if (val < 0.3) return color(10, 30, 80); 
                if (val < 0.45) return color(30, 80, 200); 
                if (val < 0.5) return color(210, 180, 140); 
                if (val < 0.65) return color(34, 139, 34); 
                if (val < 0.8) return color(100, 100, 100); 
                return color(255); 
            }
            if (theme === 'lava') {
                colorMode(RGB, 255);
                if (val < 0.3) return color(20, 5, 5);
                if (val < 0.6) return lerpColor(color(20, 5, 5), color(255, 60, 0), map(val, 0.3, 0.6, 0, 1));
                return lerpColor(color(255, 60, 0), color(255, 255, 0), map(val, 0.6, 1, 0, 1));
            }
            if (theme === 'ocean') {
                 colorMode(RGB, 255);
                 if (val < 0.5) return lerpColor(color(0,0,50), color(0,100,200), map(val,0,0.5,0,1));
                 return lerpColor(color(0,100,200), color(150,255,255), map(val,0.5,1,0,1));
            }
            colorMode(RGB, 255);
            return color(255);
        }

        function updateProbe() {
            if (mouseX >= 0 && mouseX < width && mouseY >= 0 && mouseY < height) {
                let n = getNoiseValue(mouseX, mouseY);
                let el = document.getElementById('probeInfo');
                el.style.display = 'block';
                el.innerHTML = `X: ${floor(mouseX)} | Y: ${floor(mouseY)} | Value: <span style="color:white">${n.toFixed(3)}</span>`;
            } else {
                document.getElementById('probeInfo').style.display = 'none';
            }
        }

        function initUI() {
            const bindSlider = (id, key, displayId) => {
                document.getElementById(id).addEventListener('input', (e) => {
                    let val = parseFloat(e.target.value);
                    params[key] = val;
                    if (displayId) {
                        document.getElementById(displayId).innerText = (val % 1 === 0) ? val : val.toFixed(2);
                    }
                    if (key === 'particleCount') initParticles();
                });
            };

            bindSlider('scaleSlider', 'scale', 'scaleVal');
            bindSlider('octavesSlider', 'octaves', 'octavesVal');
            bindSlider('persistenceSlider', 'persistence', 'persistenceVal');
            bindSlider('lacunaritySlider', 'lacunarity', 'lacunarityVal');
            bindSlider('speedSlider', 'speed', 'speedVal');
            bindSlider('stepCountSlider', 'stepCount', 'stepCountVal');
            bindSlider('gridSizeSlider', 'gridSize', 'gridSizeVal');
            bindSlider('pCountSlider', 'particleCount', 'pCountVal');
            
            const bindCheck = (id, key) => {
                document.getElementById(id).addEventListener('change', (e) => {
                    params[key] = e.target.checked;
                    if (key === 'trails' && !e.target.checked) {
                         background(0);
                    }
                    if(key === 'showParticles' && e.target.checked) initParticles();
                });
            };
            bindCheck('bgToggle', 'showBg');
            bindCheck('stepToggle', 'stepping');
            bindCheck('vectorToggle', 'showVectors');
            bindCheck('trailToggle', 'trails');

            document.getElementById('themeSelect').addEventListener('change', (e) => params.theme = e.target.value);

            // Seed logic modified to use the global updateSeed function
            document.getElementById('seedInput').addEventListener('input', updateSeed);
            document.getElementById('randomSeedBtn').addEventListener('click', () => {
                document.getElementById('seedInput').value = Math.floor(Math.random()*100000).toString();
                updateSeed();
            });
            
            document.getElementById('exportBtn').addEventListener('click', exportImage);
        }

        function exportImage() {
            let w = parseInt(document.getElementById('exportW').value);
            let h = parseInt(document.getElementById('exportH').value);
            
            if (isNaN(w) || isNaN(h) || w < 100 || h < 100) {
                console.error("ç„¡æ•ˆçš„åŒ¯å‡ºå°ºå¯¸ã€‚");
                return;
            }

            document.getElementById('loadingOverlay').style.display = 'flex';
            
            setTimeout(() => {
                let pg = createGraphics(w, h);
                pg.pixelDensity(1);
                pg.background(0);
                pg.loadPixels();
                
                const highResNoiseFunc = (x, y) => {
                    let nx = x * (PREVIEW_SIZE/w);
                    let ny = y * (PREVIEW_SIZE/h);
                    
                    let total = 0;
                    let amplitude = 1;
                    let frequency = params.scale;
                    let maxValue = 0;

                    for (let i = 0; i < params.octaves; i++) {
                        total += noise(nx * frequency, ny * frequency, params.zOff * frequency) * amplitude;
                        maxValue += amplitude;
                        amplitude *= params.persistence;
                        frequency *= params.lacunarity;
                    }
                    return total / maxValue;
                };

                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        let n = highResNoiseFunc(x, y); 
                        if (params.stepping) n = floor(n * params.stepCount) / (params.stepCount - 1);
                        let c = getThemeColor(n, params.theme);
                        pg.set(x, y, c);
                    }
                }
                pg.updatePixels();
                
                save(pg, `noise_${params.seed}_${params.theme}_${w}x${h}`, 'png');
                pg.remove(); 
                document.getElementById('loadingOverlay').style.display = 'none';
            }, 100); 
        }
    </script>
</body>
</html>
